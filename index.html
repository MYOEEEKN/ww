<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ALPHA X AI - Predictor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=El+Messiri:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.4/gsap.min.js"></script>
    <script type="module" src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.esm.js"></script>
    <script nomodule src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.js"></script>
    <style>
        :root {
            --bg-dark-primary: #1a202c; /* Dark Charcoal */
            --bg-dark-secondary: #2d3748; /* Slightly Lighter Charcoal */
            --bg-dark-tertiary: #171923; /* Even Darker for depth */
            --text-light-primary: #edf2f7; /* Light Gray */
            --text-light-secondary: #a0aec0; /* Medium Gray */
            --accent-primary: #38b2ac; /* Teal */
            --accent-secondary: #4299e1; /* Vibrant Blue */
            --card-border-color: #4a5568; /* Dark Gray border */
            --shadow-color: rgba(0, 0, 0, 0.4);
            --shadow-accent-glow: rgba(56, 178, 172, 0.3); /* Teal glow */

            --win-color: #38a169; /* Green */
            --loss-color: #e53e3e; /* Red */
            --pending-color: #dd6b20; /* Orange */
            --skipped-color: #718096; /* Gray */
            --warning-color: #f59e0b; /* Amber - for pending/warning states in login */
            --maintenance-text-color: #ecc94b; /* Yellow for maintenance */

            /* Input specific styles for dark theme */
            --input-bg-dark: rgba(45, 55, 72, 0.7);
            --input-border-dark: var(--card-border-color);
            --input-focus-border-dark: var(--accent-primary);
            --input-focus-shadow-dark: var(--shadow-accent-glow);

            /* New light accent colors */
            --accent-light-1: #E0E7FF; /* Light Lavender/Blueish */
            --accent-light-2: #D1FAE5; /* Light Mint/Greenish */
            --accent-highlight: #F0FDFA; /* Very subtle off-white/teal */
            --disabled-timer-bg: rgba(30, 41, 59, 0.97); /* Dark Slate for timer popup */
        }

        body {
            font-family: 'El Messiri', sans-serif;
            background: linear-gradient(135deg, var(--bg-dark-primary), var(--bg-dark-secondary));
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
            margin: 0;
            padding: 0;
            color: var(--text-light-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center; /* Center content by default (for login/maintenance) */
        }
        * {
            color: var(--text-light-primary);
        }

        /* New Login System Styles - Adapted for AlphaX Theme */
        .auth-screen {
            display: none; /* Hidden by default, JS controls visibility */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%;
            min-height: 95vh; /* Ensure it takes full viewport height */
            padding: 1rem;
            animation: fadeInAuthAlphaX 0.7s ease-out;
        }
        .auth-screen.active {
            display: flex;
        }

        @keyframes fadeInAuthAlphaX {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .auth-container-alphax {
            background: var(--bg-dark-secondary);
            padding: 2rem 2.5rem;
            border-radius: 1.5rem; /* Consistent with AlphaX card radius */
            box-shadow: 0 10px 25px var(--shadow-color);
            width: 100%;
            max-width: 450px;
            text-align: center;
            border: 1px solid var(--card-border-color);
        }

        .auth-title-svg-alphax { /* Reusing existing SVG style for title */
            width: 100%;
            max-width: 350px; /* Adjusted for slightly smaller title */
            margin: 0 auto 1.5rem auto;
        }
        .auth-title-svg-alphax svg text {
            font-family: 'El Messiri', sans-serif; text-anchor: middle; dominant-baseline: middle;
            text-transform: uppercase; animation: strokeLoginDark 5s infinite alternate;
            stroke-width: 1.2; stroke: var(--accent-primary);
            font-size: 50px; /* Adjusted font size */
            fill: rgba(26, 32, 44, 0); letter-spacing: 1px;
        }
         @keyframes strokeLoginDark { /* Copied from existing alphax for consistency */
            0% { fill: rgba(26, 32, 44, 0); stroke: var(--accent-primary); stroke-dashoffset: 25%; stroke-dasharray: 0 50%; stroke-width: 1.2; }
            70% { fill: rgba(26, 32, 44, 0); stroke: var(--accent-secondary); }
            80% { fill: rgba(26, 32, 44, 0); stroke: var(--accent-primary); stroke-width: 2.5; }
            100% { fill: var(--text-light-primary); stroke: rgba(56, 178, 172, 0); stroke-dashoffset: -25%; stroke-dasharray: 50% 0; stroke-width: 0; }
        }


        .auth-subtitle-alphax {
            font-size: 0.9rem;
            color: var(--text-light-secondary);
            margin-bottom: 1.5rem;
        }

        .form-input-alphax {
            width: 100%;
            padding: 0.9rem 1.2rem;
            border: 1px solid var(--input-border-dark);
            border-radius: 1rem; /* Consistent with AlphaX input */
            margin-bottom: 1rem;
            font-size: 1rem;
            background-color: var(--input-bg-dark);
            color: var(--text-light-primary);
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }
        .form-input-alphax:focus {
            outline: none;
            border-color: var(--input-focus-border-dark);
            box-shadow: 0 0 0 4px var(--input-focus-shadow-dark);
        }

        .auth-button-alphax { /* Adapting .login-btn-main style */
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            color: var(--bg-dark-tertiary);
            padding: 0.9rem 1.8rem; border-radius: 1rem; font-weight: 600;
            transition: all 0.3s ease; border: none; cursor: pointer;
            display: inline-flex; align-items: center; justify-content: center; gap: 0.6rem;
            text-transform: uppercase; letter-spacing: 0.5px;
            box-shadow: 0 5px 12px rgba(0,0,0,0.2); width: 100%;
        }
        .auth-button-alphax:hover {
            transform: translateY(-3px) scale(1.03);
            box-shadow: 0 8px 18px var(--shadow-accent-glow);
        }
        .auth-button-alphax:disabled {
            background: #4a5568; color: var(--text-light-secondary);
            cursor: not-allowed; opacity: 0.8;
        }

        .device-id-display-alphax {
            background-color: rgba(45, 55, 72, 0.6); /* From .login-device-id-display */
            border: 1px dashed var(--card-border-color);
            color: var(--text-light-secondary);
            padding: 1rem; border-radius: 0.75rem; margin-bottom: 1.5rem;
            text-align: left; font-size: 0.9rem;
        }
        .device-id-display-alphax strong {
            font-weight: 600; user-select: all; cursor: pointer;
            word-break: break-all; color: var(--accent-primary); /* Teal for Device ID */
        }
        .copy-btn-sm-alphax {
            background: none; border: none; color: var(--accent-primary);
            cursor: pointer; font-size: 0.9em; margin-left: 0.5rem;
        }
        .copy-feedback-alphax { /* From .login-copy-feedback */
            display: none; color: var(--win-color); font-size: 0.75rem;
            margin-left: 0.5rem; font-weight: 500; opacity: 0;
        }
        .copy-feedback-alphax.show { display: inline; animation: fadeInOutLoginFeedback 2.5s forwards; }
        @keyframes fadeInOutLoginFeedback { /* Copied from AlphaX */
          0% { opacity: 0; transform: translateY(5px); }
          20% { opacity: 1; transform: translateY(0); }
          80% { opacity: 1; transform: translateY(0); }
          100% { opacity: 0; transform: translateY(-5px); }
        }


        .status-message-container-alphax {
            margin-top: 1.5rem; padding: 0.75rem; border-radius: 1rem;
            font-size: 0.9rem; min-height: 60px;
            display: flex; align-items: center; justify-content: center; text-align: center;
            border: 1px solid var(--card-border-color);
        }
        .status-pending-alphax { background-color: var(--pending-color); color: var(--bg-dark-tertiary); }
        .status-approved-alphax { background-color: var(--win-color); color: var(--bg-dark-tertiary); }
        .status-rejected-alphax { background-color: var(--loss-color); color: var(--text-light-primary); }
        .status-expired-alphax { background-color: var(--warning-color); color: var(--bg-dark-tertiary); }
        .status-info-alphax { background-color: var(--input-bg-dark); color: var(--text-light-secondary); }

        .tick-animation-alphax { display: inline-block; }
        .tick-animation-alphax svg { width: 30px; height: 30px; }
        .tick-animation-alphax .tick-circle { stroke-dasharray: 166; stroke-dashoffset: 166; animation: strokeAlphaX 0.6s cubic-bezier(0.65, 0, 0.45, 1) forwards; fill: none; stroke: var(--win-color); stroke-width:3; stroke-linecap: round; }
        .tick-animation-alphax .tick-path { transform-origin: 50% 50%; stroke-dasharray: 48; stroke-dashoffset: 48; animation: strokeAlphaX 0.3s cubic-bezier(0.65, 0, 0.45, 1) 0.4s forwards; fill: none; stroke: var(--win-color); stroke-width:3; stroke-linecap: round; stroke-linejoin: round; }
        @keyframes strokeAlphaX { 100% { stroke-dashoffset: 0; } }

        .auth-footer-link-alphax { margin-top: 1.5rem; font-size: 0.8rem; color: var(--text-light-secondary); }
        .auth-footer-link-alphax a { color: var(--accent-primary); text-decoration: none; font-weight: 500; }
        .auth-footer-link-alphax a:hover { text-decoration: underline; color: var(--accent-secondary); }

        /* Existing AlphaX styles */
        #maintenanceContainer { display: none; width:100%; max-width:450px; padding:2rem; animation: fadeInLogin 0.8s ease-in-out;}
        #maintenanceContainer.active { display: block; }
        .maintenance-card { background: var(--bg-dark-secondary); border-radius: 1.5rem; box-shadow: 0 10px 25px var(--shadow-color); padding: 2.5rem; border: 1px solid var(--card-border-color); text-align: center;}
        .maintenance-card i { font-size: 3rem; color: var(--maintenance-text-color); margin-bottom: 1rem; }
        .maintenance-card h2 { color: var(--maintenance-text-color); margin-bottom: 0.5rem; }

        #appContainer { display: none; width: 100%; transition: filter 0.3s ease-in-out; }
        #appContainer.active { display: block; }
        .app-content-blurred {
            filter: blur(4px);
            pointer-events: none;
        }


        .popup, .modal {
            display: none; position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%); background: rgba(45, 55, 72, 0.95);
            padding: 1.5rem; border-radius: 1.5rem; box-shadow: 0 6px 16px var(--shadow-color);
            backdrop-filter: blur(8px); z-index: 1000; width: 90%; max-width: 400px;
            border: 1px solid var(--accent-light-1); text-align: center;
        }
        .popup h3, .modal h3 { font-size: 1.25rem; font-weight: 600; margin-bottom: 1rem; color: var(--accent-highlight); }
        .popup p, .modal p { margin-bottom: 1.5rem; color: var(--text-light-secondary); font-size: 0.9rem; }
        .popup .button-group, .modal .button-group { display: flex; justify-content: space-around; gap: 1rem; }
        .popup button, .modal button {
            padding: 0.6rem 1.2rem; border-radius: 0.75rem; font-weight: 500;
            transition: all 0.2s ease; border: none; cursor: pointer;
            min-width: 100px;
        }
        .popup button.primary, .modal button.primary { background: var(--accent-primary); color: var(--bg-dark-tertiary); }
        .popup button.primary:hover, .modal button.primary:hover { background: var(--accent-secondary); }
        .popup button.secondary, .modal button.secondary { background: var(--bg-dark-tertiary); color: var(--text-light-primary); border: 1px solid var(--card-border-color); }
        .popup button.secondary:hover, .modal button.secondary:hover { background: var(--card-border-color); }
        .popup button.danger, .modal button.danger { background: var(--loss-color); color: var(--text-light-primary); }
        .popup button.danger:hover, .modal button.danger:hover { background: #c53030; }


        .popup.active, .modal.active { display: block; animation: fadeInPopup 0.3s ease-out; }
        @keyframes fadeInPopup {
            from { opacity: 0; transform: translate(-50%, -45%) scale(0.95); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        /* Prediction Disabled Popup */
        #predictionDisabledPopup {
            background: var(--disabled-timer-bg);
            border-top: 4px solid var(--warning-color);
            z-index: 1001; /* Ensure it's above blurred content */
        }
        #predictionDisabledPopup h3 { color: var(--warning-color); }
        #predictionDisabledPopup p { color: var(--accent-light-1); }
        #predictionDisabledTimer {
            font-size: 2rem;
            font-weight: bold;
            color: var(--accent-primary);
            margin: 1rem 0;
            padding: 0.5rem;
            background-color: rgba(0,0,0,0.2);
            border-radius: 0.5rem;
        }


        .card {
            transition: all 0.3s ease; background: var(--bg-dark-secondary);
            border-radius: 1.5rem; box-shadow: 0 6px 12px var(--shadow-color);
            backdrop-filter: blur(5px); position: relative; margin: 0.75rem;
            overflow: hidden; border: 1px solid var(--card-border-color);
        }
        .card:hover {
            transform: translateY(-6px) scale(1.03);
            box-shadow: 0 8px 16px var(--shadow-accent-glow);
            border-color: var(--accent-primary);
        }
        .gradient-bg { background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary)); }
        #appHeaderSvgContainer svg { width: 100%; height: auto; margin: 0 auto; display: block; }
        #appHeaderSvgContainer svg text {
            text-anchor: middle; dominant-baseline: middle; text-transform: uppercase;
            animation: strokeAppHeaderDark 5s infinite alternate; stroke-width: 1.2;
            stroke: var(--accent-primary); font-size: 130px; fill: rgba(26, 32, 44, 0);
        }
        @media (max-width: 768px) { #appHeaderSvgContainer svg text { font-size: 90px; } }
        @keyframes strokeAppHeaderDark {
            0% { fill: rgba(26, 32, 44, 0); stroke: var(--accent-primary); stroke-dashoffset: 25%; stroke-dasharray: 0 50%; stroke-width: 1.2; }
            70% { fill: rgba(26, 32, 44, 0); stroke: var(--accent-secondary); }
            80% { fill: rgba(26, 32, 44, 0); stroke: var(--accent-primary); stroke-width: 2.5; }
            100% { fill: var(--text-light-primary); stroke: rgba(56, 178, 172, 0); stroke-dashoffset: -25%; stroke-dasharray: 50% 0; stroke-width: 0; }
        }
        .history-container { display: flex; flex-direction: column; gap: 1rem; max-height: none; overflow: visible; position: relative; }
        .history-item {
            transition: all 0.3s ease; width: 100%; max-width: 100%; margin: 0; border-radius: 1.2rem;
            background: var(--bg-dark-tertiary); backdrop-filter: blur(5px);
            box-shadow: 0 4px 14px rgba(0,0,0,0.2); position: relative; overflow: hidden; padding: 1.2rem;
            border-left: 4px solid transparent;
        }
        .history-item.win { border-left-color: var(--win-color); background: linear-gradient(135deg, rgba(56, 161, 105, 0.2), var(--bg-dark-tertiary)); }
        .history-item.loss { border-left-color: var(--loss-color); background: linear-gradient(135deg, rgba(229, 62, 62, 0.2), var(--bg-dark-tertiary)); }
        .history-item.pending { border-left-color: var(--pending-color); background: linear-gradient(135deg, rgba(221, 107, 32, 0.2), var(--bg-dark-tertiary)); }
        .history-item.skipped { border-left-color: var(--skipped-color); background: linear-gradient(135deg, rgba(113, 128, 150, 0.2), var(--bg-dark-tertiary)); }
        .history-item:hover { transform: scale(1.02); box-shadow: 0 6px 18px var(--shadow-accent-glow); }
        .history-item.fade-out { animation: fadeOut 0.5s ease forwards; }
        @keyframes fadeOut { 0% { opacity: 1; transform: scale(1); } 100% { opacity: 0; transform: scale(0.95); height: 0; padding: 0; margin: 0; } }
        .history-item .watermark {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) rotate(-45deg);
            font-size: 1.5rem; color: rgba(74, 85, 104, 0.2);
            pointer-events: none; z-index: 0; text-transform: uppercase; font-weight: bold;
        }
        .small-dot {
            position: absolute; width: 6px; height: 6px; background: var(--accent-secondary);
            border-radius: 50%; animation: float 4s infinite; z-index: 1;
        }
        @keyframes float { 0% { transform: translate(0, 0); opacity: 0.7; } 50% { transform: translate(12px, -12px); opacity: 0.3; } 100% { transform: translate(0, 0); opacity: 0.7; } }
        .delete-btn:hover { color: var(--accent-primary); transform: scale(1.3); }
        .status-icon {
            width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center;
            font-size: 18px; position: relative; overflow: hidden;
        }
        .status-icon::after {
            content: ''; position: absolute; top: -50%; left: -50%; width: 200%; height: 200%;
            opacity: 0.1; background: radial-gradient(circle, currentColor 0%, transparent 70%);
        }
        .win-icon { color: var(--win-color); animation: pulseWin 1.5s infinite; }
        .loss-icon { color: var(--loss-color); animation: pulseLoss 1s infinite; }
        .pending-icon { color: var(--pending-color); animation: rotate 2s infinite linear; }
        .skipped-icon { color: var(--skipped-color); animation: pulseSkip 1.5s infinite; }
        @keyframes pulseWin { 0%, 100% { box-shadow: 0 0 0 0 rgba(56, 161, 105, 0.5); } 50% { box-shadow: 0 0 0 10px rgba(56, 161, 105, 0); } }
        @keyframes pulseLoss { 0%, 100% { box-shadow: 0 0 0 0 rgba(229, 62, 62, 0.5); } 50% { box-shadow: 0 0 0 10px rgba(229, 62, 62, 0); } }
        @keyframes rotate { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        @keyframes pulseSkip { 0%, 100% { opacity: 0.7; } 50% { opacity: 1; } }

        .dashboard-card {
            background: var(--bg-dark-tertiary); border-radius: 1.5rem; padding: 1.2rem;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2); backdrop-filter: blur(5px); transition: all 0.3s ease;
            border: 1px solid var(--card-border-color);
        }
        .dashboard-card:hover { transform: translateY(-4px); box-shadow: 0 6px 14px var(--shadow-accent-glow); border-color: var(--accent-primary); }
        .confidence-meter { height: 10px; background: var(--bg-dark-primary); border-radius: 5px; overflow: hidden; position: relative; }
        .confidence-fill { height: 100%; background: var(--accent-primary); transition: width 0.5s ease; }

        /* Navigation Styles - Revised Indicator */
        .navigation {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            width: 90%; max-width: 380px; height: 70px; background: rgba(45, 55, 72, 0.9);
            backdrop-filter: blur(8px); display: flex; justify-content: center; align-items: center;
            border-radius: 1.5rem; box-shadow: 0 6px 12px var(--shadow-color); z-index: 1000;
            border: 1px solid var(--card-border-color);
        }
        .navigation ul { display: flex; width: 100%; justify-content: space-around; padding: 0 10px; }
        .navigation ul li { position: relative; list-style: none; width: 25%; height: 70px; z-index: 1; display: flex; align-items: center; justify-content: center;}
        .navigation ul li a {
            position: relative; display: flex; justify-content: center; align-items: center;
            flex-direction: column; width: 100%; text-align: center; font-weight: 500;
            padding-top: 5px; /* Space for icon movement */
        }
        .navigation ul li a .icon {
            position: relative; display: block; line-height: initial; /* Adjusted for better centering */
            font-size: 1.5em; text-align: center; transition: 0.5s ease; color: var(--text-light-secondary);
            transform: translateY(0px); /* Initial position */
        }
        .navigation ul li.active a .icon {
            transform: translateY(-18px); /* Move icon up */
            color: var(--accent-primary);
        }
        .navigation ul li a .text {
            position: absolute; font-weight: 400; font-size: 0.75em; letter-spacing: 0.05em;
            transition: 0.5s ease; opacity: 0; transform: translateY(20px); color: var(--text-light-primary);
            bottom: 8px; /* Position text at the bottom */
        }
        .navigation ul li.active a .text {
            opacity: 1; transform: translateY(0px); /* Text appears below icon */
            color: var(--accent-primary);
        }
        /* New Underline Indicator */
        .navigation ul li a::after {
            content: '';
            position: absolute;
            bottom: -2px; /* Position underline slightly below the item */
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 3px;
            background-color: var(--accent-primary);
            border-radius: 3px;
            transition: width 0.4s cubic-bezier(0.68, -0.55, 0.27, 1.55); /* Smooth elastic transition */
        }
        .navigation ul li.active a::after {
            width: 50%; /* Width of the underline for active item */
        }


        /* Mode Toggle Styles */
        .mode-toggle { display: flex; align-items: center; justify-content: space-between; padding: 0.5rem 0; }
        .mode-toggle label { font-size: 0.9rem; color: var(--text-light-secondary); }
        .mode-switch { position: relative; display: inline-block; width: 50px; height: 26px; }
        .mode-switch input { opacity: 0; width: 0; height: 0; }
        .mode-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--input-bg-dark); transition: .4s; border-radius: 26px; border: 1px solid var(--card-border-color); }
        .mode-slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 4px; bottom: 3px; background-color: var(--text-light-secondary); transition: .4s; border-radius: 50%; }
        input:checked + .mode-slider { background-color: var(--accent-primary); }
        input:checked + .mode-slider:before { transform: translateX(24px); background-color: var(--bg-dark-tertiary); }
        .mode-icons { display: flex; justify-content: space-between; width: 100%; margin-top: 0.3rem; }
        .mode-icons span { font-size: 0.7rem; color: var(--text-light-secondary); }
        .mode-icons i { font-size: 0.8rem; color: var(--text-light-secondary); }
        input:checked ~ .mode-icons span:first-child, input:checked ~ .mode-icons i:first-child { color: var(--text-light-secondary); opacity: 0.6; }
        input:not(:checked) ~ .mode-icons span:last-child, input:not(:checked) ~ .mode-icons i:last-child { color: var(--text-light-secondary); opacity: 0.6; }
        input:checked ~ .mode-icons span:last-child, input:checked ~ .mode-icons i:last-child { color: var(--accent-primary); opacity: 1; }
        input:not(:checked) ~ .mode-icons span:first-child, input:not(:checked) ~ .mode-icons i:first-child { color: var(--accent-primary); opacity: 1; }


        .period-id { font-family: monospace; letter-spacing: 2px; font-size: 1.2rem; color: var(--accent-secondary); }
        #currentPeriod, #currentResult {
            border: none !important; background-color: var(--bg-dark-tertiary) !important;
            color: var(--text-light-primary) !important; box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
        }
        .video-container { position: relative; padding-bottom: 56.25%; /* 16:9 */ height: 0; overflow: hidden; max-width: 100%; background: #000; border-radius: 1rem; margin-top: 1rem;}
        .video-container iframe { position: absolute; top: 0; left: 0; width: 100%; height: 100%; border-radius: 1rem; }

        button, .btn {
            padding: 0.6rem 1.2rem; border-radius: 0.75rem; font-weight: 600;
            transition: all 0.3s ease; border: none; cursor: pointer;
            display: inline-flex; align-items: center; justify-content: center; gap: 0.5rem;
            text-transform: uppercase; letter-spacing: 0.5px;
            box-shadow: 0 3px 8px rgba(0,0,0,0.15);
        }
        button.primary-btn, .btn.primary-btn { background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary)); color: var(--bg-dark-tertiary); }
        button.primary-btn:hover, .btn.primary-btn:hover { transform: translateY(-2px) scale(1.02); box-shadow: 0 5px 12px var(--shadow-accent-glow); }
        button.secondary-btn, .btn.secondary-btn { background: var(--bg-dark-tertiary); color: var(--text-light-primary); border: 1px solid var(--card-border-color); }
        button.secondary-btn:hover, .btn.secondary-btn:hover { background: var(--card-border-color); color: var(--text-light-primary); }


        .bad-trend-indicator {
            background-color: var(--loss-color); color: var(--text-light-primary);
            padding: 0.75rem 1rem; border-radius: 0.75rem; margin: 0.5rem auto;
            text-align: center; font-size: 0.9rem; display: flex; align-items: center; justify-content: center;
            gap: 0.5rem; animation: pulseWarning 1.5s infinite; max-width: 95%;
        }
        @keyframes pulseWarning { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.8; transform: scale(1.02); } }

        .toast-login {
            position: fixed; bottom: 90px; left: 50%; transform: translateX(-50%);
            background-color: var(--bg-dark-tertiary); color: var(--text-light-primary);
            padding: 1rem 1.5rem; border-radius: 1rem; box-shadow: 0 4px 12px var(--shadow-color);
            z-index: 2000; display: flex; align-items: center; gap: 0.75rem;
            font-size: 0.9rem; border: 1px solid var(--card-border-color);
            animation: toast-slide-in-out-login 4s forwards;
        }
        @keyframes toast-slide-in-out-login {
            0% { bottom: -60px; opacity: 0; }
            15% { bottom: 90px; opacity: 1; }
            85% { bottom: 90px; opacity: 1; }
            100% { bottom: -60px; opacity: 0; }
        }
        .toast-login .icon { font-size: 1.2rem; }
        .toast-login .icon.success { color: var(--win-color); }
        .toast-login .icon.error { color: var(--loss-color); }
        .toast-login .icon.info { color: var(--accent-secondary); }


        .text-slate-700 { color: var(--text-light-secondary) !important; }
        .bg-slate-100 { background-color: var(--bg-dark-primary) !important; }
        .border-slate-300 { border-color: var(--card-border-color) !important; }

        .content-section { display: none; animation: fadeInSection 0.5s ease-out; padding-bottom: 80px; /* Space for nav */ }
        .content-section.active { display: block; }
        @keyframes fadeInSection { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; }

        /* About section list styling */
        #aboutSection ul {
            list-style-type: none;
            padding-left: 0;
        }
        #aboutSection ul li {
            background: rgba(255,255,255,0.03);
            margin-bottom: 0.5rem;
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            border-left: 3px solid var(--accent-primary);
            font-size: 0.85rem;
        }
         #aboutSection ul li strong {
            color: var(--accent-light-2); /* Light mint for emphasis */
         }


        @media (max-width: 768px) {
            .auth-container-alphax { padding: 1.5rem; }
            .auth-title-svg-alphax svg text { font-size: 40px; }
            .navigation { width: 95%; }
            .navigation ul li a .icon { font-size: 1.3em; }
            .navigation ul li.active a .icon { transform: translateY(-15px); } /* Adjusted for smaller screens */
            .navigation ul li a .text { bottom: 5px; font-size: 0.7em; }
            .navigation ul li.active a::after { width: 40%; }
            .card { margin: 0.5rem; }
            .popup, .modal { width: 95%; }
        }
    </style>
</head>
<body>
    <div id="loginPage1AlphaX" class="auth-screen active">
        <div class="auth-container-alphax">
            <div class="auth-title-svg-alphax">
                <svg viewBox="0 0 500 100"> <text x="50%" y="50%">ALPHA X AI</text> </svg>
            </div>
            <p class="auth-subtitle-alphax">Enter your Telegram Username to begin.</p>
            <input type="text" id="telegramUsernameInputAlphaX" class="form-input-alphax" placeholder="YourTelegramUsername (no @)">
            <button id="submitUsernameBtnAlphaX" class="auth-button-alphax mt-4">Continue</button>
            <p id="usernameErrorAlphaX" class="text-xs mt-2" style="color: var(--loss-color); display: none;">Please enter a valid username.</p>
        </div>
    </div>

    <div id="loginPage2AlphaX" class="auth-screen">
        <div class="auth-container-alphax">
            <h2 class="text-xl font-semibold text-center mb-2 text-text-light-primary">Device Verification</h2>
            <p class="auth-subtitle-alphax">Your unique Device ID is below. Share it with the admin for approval.</p>

            <div class="device-id-display-alphax">
                <p>Your Device ID:</p>
                <p>
                    <strong id="displayedDeviceIdAlphaX">Loading...</strong>
                    <button id="copyDeviceIdBtnAlphaX" class="copy-btn-sm-alphax" title="Copy Device ID"><i class="fas fa-copy"></i></button>
                    <span id="copyFeedbackAlphaX" class="copy-feedback-alphax">Copied!</span>
                </p>
            </div>

            <div id="approvalStatusContainerAlphaX" class="status-message-container-alphax status-info-alphax">
                <i class="fas fa-spinner fa-spin mr-2"></i> Checking status...
            </div>

            <button id="logoutFromDevicePageBtnAlphaX" class="auth-button-alphax w-full mt-6" style="background: var(--skipped-color); color:var(--text-light-primary);">
                <i class="fas fa-sign-out-alt mr-2"></i>Logout
            </button>
            <p class="auth-footer-link-alphax">Need help? Contact <a href="https://t.me/ALPHAXAIWEB" target="_blank" rel="noopener noreferrer">Support</a>.</p>
        </div>
    </div>

    <div id="maintenanceContainer">
        <div class="maintenance-card">
            <i class="fas fa-tools"></i>
            <h2 class="text-2xl font-bold mb-2">Under Maintenance</h2>
            <p id="maintenanceMessage" class="text-text-light-secondary">The platform is currently undergoing scheduled maintenance. Please try again later.</p>
        </div>
    </div>

    <div id="appContainer" class="pb-20">
        <div id="badTrendIndicator" class="bad-trend-indicator" style="display: none;">
            <i class="fas fa-exclamation-triangle"></i>
            <span id="badTrendMessage">Prediction temporarily disabled - Unstable trend detected</span>
        </div>

        <header id="appHeaderSvgContainer" class="text-center mt-0 mb-2 animate__animated animate__fadeInDown">
            <svg viewBox="0 0 800 120">
                <text x="50%" y="50%">ALPHA X AI</text>
            </svg>
        </header>

        <div class="max-w-full mx-auto p-2 w-full">
            <div class="max-w-4xl mx-auto p-2 w-full">
                <div id="homeSection" class="content-section active">
                    <div class="card mb-4 overflow-hidden gradient-bg animate__animated animate__zoomIn relative">
                        <div class="bg-dark-tertiary bg-opacity-80 p-6 rounded-lg pulse-animation">
                             <div class="grid grid-cols-1 sm:grid-cols-2 gap-4"> <div class="relative">
                                    <div class="pl-2">
                                        <div class="flex items-center space-x-2 mb-2">
                                            <i class="fas fa-calendar-alt text-2xl animate__animated animate__bounce text-accent-secondary"></i>
                                            <h2 class="text-2xl font-bold" data-lang-key="period">Period</h2>
                                        </div>
                                        <p id="currentPeriod" class="text-2xl font-semibold p-3 rounded-lg shadow-inner period-id">-</p>
                                    </div>
                                </div>
                                <div class="relative text-right">
                                    <div class="pr-2">
                                        <div class="flex items-center justify-end space-x-2 mb-2">
                                            <h2 class="text-2xl font-bold" data-lang-key="prediction">Prediction</h2>
                                            <i class="fas fa-poll text-2xl animate__animated animate__bounce text-accent-secondary"></i>
                                        </div>
                                        <p id="currentResult" class="text-2xl font-semibold p-3 rounded-lg shadow-inner">-</p>
                                    </div>
                                </div>
                            </div>
                            <div class="mt-4">
                                <p class="text-sm text-text-light-secondary" data-lang-key="confidence">Confidence</p>
                                <div class="confidence-meter">
                                    <div id="confidenceFill" class="confidence-fill" style="width: 0%"></div>
                                </div>
                                <p id="confidenceText" class="text-sm mt-1 text-text-light-secondary">0%</p>
                            </div>
                        </div>
                        <div class="small-dot" style="top: 15%; left: 15%; animation-delay: 0.2s;"></div>
                        <div class="small-dot" style="top: 25%; left: 75%; animation-delay: 0.5s;"></div>
                        <div class="small-dot" style="top: 65%; left: 25%; animation-delay: 0.8s;"></div>
                        <div class="small-dot" style="top: 80%; left: 85%; animation-delay: 1.1s;"></div>
                        <div class="small-dot" style="top: 50%; left: 5%; animation-delay: 1.4s;"></div>
                        <div class="small-dot" style="top: 5%; left: 50%; animation-delay: 1.7s;"></div>
                    </div>
                    <div class="card mb-4 p-6 animate__animated animate__fadeInUp relative">
                        <h2 class="text-3xl font-bold text-center mb-4 relative text-accent-primary">
                            <span class="relative z-10 pulse-animation" data-lang-key="analysis_dashboard">Analysis Dashboard</span>
                            <span class="absolute top-1/2 left-0 w-full h-1 bg-accent-primary opacity-30 -translate-y-1/2 rounded-full"></span>
                        </h2>
                        <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4">
                            <div class="dashboard-card animate__animated animate__fadeIn" style="animation-delay: 0s;">
                                <div class="flex items-center space-x-2">
                                    <i class="fas fa-star text-lg text-accent-secondary"></i>
                                    <div>
                                        <p class="text-sm text-text-light-secondary" data-lang-key="most_frequent_bs">Most Frequent (B/S)</p>
                                        <p id="mostFrequentBigSmall" class="text-xl font-bold text-text-light-primary">-</p>
                                    </div>
                                </div>
                            </div>
                            <div class="dashboard-card animate__animated animate__fadeIn" style="animation-delay: 0.1s;">
                                <div class="flex items-center space-x-2">
                                    <i class="fas fa-moon text-lg text-accent-secondary"></i>
                                    <div>
                                        <p class="text-sm text-text-light-secondary" data-lang-key="least_frequent_bs">Least Frequent (B/S)</p>
                                        <p id="leastFrequentBigSmall" class="text-xl font-bold text-text-light-primary">-</p>
                                    </div>
                                </div>
                            </div>
                            <div class="dashboard-card animate__animated animate__fadeIn" style="animation-delay: 0.2s;">
                                <div class="flex items-center space-x-2">
                                    <i class="fas fa-chart-line text-lg text-accent-secondary"></i>
                                    <div>
                                        <p class="text-sm text-text-light-secondary" data-lang-key="win_rate">Win Rate</p>
                                        <p id="winRate" class="text-xl font-bold text-text-light-primary">-%</p>
                                    </div>
                                </div>
                            </div>
                            <div class="dashboard-card animate__animated animate__fadeIn" style="animation-delay: 0.3s;">
                                <div class="flex items-center space-x-2">
                                    <i class="fas fa-trophy text-lg text-win-color"></i>
                                    <div>
                                        <p class="text-sm text-text-light-secondary" data-lang-key="wins">Wins</p>
                                        <p id="totalWinBets" class="text-xl font-bold text-text-light-primary">-</p>
                                    </div>
                                </div>
                            </div>
                            <div class="dashboard-card animate__animated animate__fadeIn" style="animation-delay: 0.4s;">
                                <div class="flex items-center space-x-2">
                                    <i class="fas fa-thumbs-down text-lg text-loss-color"></i>
                                    <div>
                                        <p class="text-sm text-text-light-secondary" data-lang-key="losses">Losses</p>
                                        <p id="totalLossBets" class="text-xl font-bold text-text-light-primary">-</p>
                                    </div>
                                </div>
                            </div>
                             <div class="dashboard-card flex items-center justify-between animate__animated animate__fadeIn" style="animation-delay: 0.5s;">
                                <div class="flex items-center space-x-2">
                                    <i class="fas fa-server text-lg text-accent-secondary"></i>
                                    <div>
                                        <p class="text-sm text-text-light-secondary" data-lang-key="server_status">Server Status</p>
                                        <p id="serverStatus" class="font-semibold text-text-light-primary" data-lang-key="connected">Connected</p>
                                    </div>
                                </div>
                                <div id="serverStatusIndicator" class="w-3 h-3 bg-win-color rounded-full animate-ping"></div>
                            </div>
                        </div>
                    </div>
                </div>
                <div id="historySection" class="content-section">
                     <div class="card p-6 animate__animated animate__fadeInUp relative">
                        <div class="flex justify-between items-center mb-4">
                            <h2 class="text-3xl font-bold text-center relative text-accent-primary">
                                <span class="relative z-10 pulse-animation" data-lang-key="history">History</span>
                                <span class="absolute top-1/2 left-0 w-full h-1 bg-accent-primary opacity-30 -translate-y-1/2 rounded-full"></span>
                            </h2>
                            <button id="deleteAllHistoryBtn" class="secondary-btn px-4 py-2 rounded-lg transition flex items-center">
                                <i class="fas fa-trash-alt mr-2"></i><span data-lang-key="delete">Delete All</span>
                            </button>
                        </div>
                        <div id="history" class="history-container">
                            <p class="text-center text-text-light-secondary p-4" data-lang-key="no_history">No history yet.</p>
                        </div>
                    </div>
                </div>
                <div id="statsSection" class="content-section">
                    <div class="card p-6 animate__animated animate__fadeInUp relative">
                        <h2 class="text-3xl font-bold text-center mb-4 relative text-accent-primary">
                            <span class="relative z-10 pulse-animation" data-lang-key="statistics">Statistics</span>
                             <span class="absolute top-1/2 left-0 w-full h-1 bg-accent-primary opacity-30 -translate-y-1/2 rounded-full"></span>
                        </h2>
                        <div class="stats-grid">
                           <div class="dashboard-card">
                                <div class="flex items-center space-x-2">
                                    <i class="fas fa-trophy text-win-color text-lg"></i>
                                    <div>
                                        <p class="text-sm text-text-light-secondary" data-lang-key="total_wins">Total Wins</p>
                                        <p id="statsTotalWins" class="text-xl font-bold text-text-light-primary">-</p>
                                    </div>
                                </div>
                            </div>
                            <div class="dashboard-card">
                                <div class="flex items-center space-x-2">
                                    <i class="fas fa-heart-broken text-loss-color text-lg"></i>
                                    <div>
                                        <p class="text-sm text-text-light-secondary" data-lang-key="total_losses">Total Losses</p>
                                        <p id="statsTotalLosses" class="text-xl font-bold text-text-light-primary">-</p>
                                    </div>
                                </div>
                            </div>
                            <div class="dashboard-card">
                                <div class="flex items-center space-x-2">
                                    <i class="fas fa-percentage text-accent-secondary text-lg"></i>
                                    <div>
                                        <p class="text-sm text-text-light-secondary" data-lang-key="win_rate">Win Rate</p>
                                        <p id="statsWinRate" class="text-xl font-bold text-text-light-primary">-%</p>
                                    </div>
                                </div>
                            </div>
                            <div class="dashboard-card">
                                <div class="flex items-center space-x-2">
                                    <i class="fas fa-fire text-orange-400 text-lg"></i>
                                    <div>
                                        <p class="text-sm text-text-light-secondary" data-lang-key="current_streak">Current Streak</p>
                                        <p id="currentStreak" class="text-xl font-bold text-text-light-primary">-</p>
                                    </div>
                                </div>
                            </div>
                            <div class="dashboard-card col-span-full sm:col-span-1 md:col-span-2">
                                <div class="flex items-center space-x-2">
                                    <i class="fas fa-history text-accent-primary text-lg"></i>
                                    <div>
                                        <p class="text-sm text-text-light-secondary" data-lang-key="last_five_actuals">Last 5 Actuals</p>
                                        <p id="lastFiveActuals" class="text-lg font-mono text-text-light-primary">-</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div id="aboutSection" class="content-section">
                     <div class="card p-6 animate__animated animate__fadeInUp relative">
                        <h2 class="text-3xl font-bold text-center mb-6 relative text-accent-primary">
                            <span class="relative z-10 pulse-animation" data-lang-key="about_aura_x_ai">About ALPHA X AI</span> <span class="absolute top-1/2 left-0 w-full h-1 bg-accent-primary opacity-30 -translate-y-1/2 rounded-full"></span>
                        </h2>
                         <div class="space-y-6 text-text-light-secondary">
                            <div>
                                <h3 class="text-xl font-semibold mb-2 text-accent-primary" data-lang-key="predictor_intro_title">Our Prediction Engine</h3>
                                <p data-lang-key="predictor_intro_p1">ALPHA X AI employs a sophisticated prediction engine designed to analyze trends and patterns from historical data. Our goal is to provide insightful predictions, but it's important to remember that these are based on statistical analysis and not guarantees of future outcomes.</p>
                                <p data-lang-key="predictor_intro_p2">The system uses an advanced multi-model approach, combining numerous analytical techniques to enhance accuracy and adapt to changing conditions. This version incorporates enhanced pattern recognition, transitional analysis, and weighted historical data to provide more nuanced predictions.</p>
                            </div>
                            <div>
                                <h3 class="text-xl font-semibold mb-2 text-accent-primary" data-lang-key="how_it_works_title">How It Works (Advanced)</h3>
                                <p class="text-sm mb-2" data-lang-key="how_it_works_subtitle_adv">Our engine integrates a diverse range of analytical approaches, from statistical methods to conceptual AI-driven techniques, to achieve robust predictions:</p>
                                <ul class="list-disc list-inside space-y-1 pl-4">
                                    <li data-lang-key="engine_sum_range"></li>
                                    <li data-lang-key="engine_high_low_ratio"></li>
                                    <li data-lang-key="engine_sum_freq_tracker"></li>
                                    <li data-lang-key="engine_num_dist"></li>
                                    <li data-lang-key="engine_consecutive_num"></li>
                                    <li data-lang-key="engine_gap_analysis"></li>
                                    <li data-lang-key="engine_machine_bias"></li>
                                    <li data-lang-key="engine_ml"></li>
                                    <li data-lang-key="engine_monte_carlo"></li>
                                    <li data-lang-key="engine_markov_chain"></li>
                                    <li data-lang-key="engine_ga"></li>
                                    <li data-lang-key="engine_fractal"></li>
                                    <li data-lang-key="engine_chaos_theory"></li>
                                    <li data-lang-key="engine_wavelet"></li>
                                    <li data-lang-key="engine_info_theory"></li>
                                    <li data-lang-key="engine_graph_theory"></li>
                                    <li data-lang-key="engine_bayesian"></li>
                                    <li data-lang-key="engine_copula"></li>
                                    <li data-lang-key="engine_rl"></li>
                                    <li data-lang-key="engine_tda"></li>
                                    <li data-lang-key="engine_rqa"></li>
                                    <li data-lang-key="engine_hmm"></li>
                                    <li data-lang-key="engine_optimal_transport"></li>
                                    <li data-lang-key="how_it_works_li1_adv"></li>
                                    <li data-lang-key="how_it_works_li2_adv"></li>
                                    <li data-lang-key="how_it_works_li3_adv"></li>
                                    <li data-lang-key="how_it_works_li4_adv"></li>
                                    <li data-lang-key="how_it_works_li11_adv"></li>
                                    <li data-lang-key="how_it_works_li_macd"></li>
                                    <li data-lang-key="how_it_works_li_bollinger"></li>
                                    <li data-lang-key="how_it_works_li_inter_signal"></li>
                                    <li data-lang-key="how_it_works_li10_adv"></li>
                                </ul>
                            </div>
                            <div>
                                <h3 class="text-xl font-semibold mb-2 text-accent-primary" data-lang-key="important_note_title">Important Note</h3>
                                <p data-lang-key="important_note_p1">All predictions provided by ALPHA X AI are for informational and entertainment purposes only. Past performance is not indicative of future results. Please use this information responsibly. Predictions are based on the device's local history and may vary if histories differ across devices.</p>
                            </div>
                            <div>
                                <h3 class="text-xl font-semibold mb-2 text-accent-primary" data-lang-key="meet_the_team_title">Meet The Team</h3>
                                <p data-lang-key="owner_info"><strong>Owner/Developer:</strong> @ALPHAXAIWEB</p>
                                <a href="https://t.me/ALPHAXAIWEB" target="_blank" rel="noopener noreferrer" class="inline-block mt-1 px-4 py-2 primary-btn text-sm rounded-lg">
                                    <i class="fab fa-telegram-plane mr-2"></i><span data-lang-key="owner_telegram">Telegram Profile</span>
                                </a>
                            </div>
                            <hr class="border-card-border-color my-6">
                            <div>
                                <h3 class="text-xl font-semibold mb-3 text-accent-primary" data-lang-key="general_settings_title">General Settings</h3>
                                <div class="space-y-4">
                                    <div class="mode-toggle">
                                        <label for="languageToggle" data-lang-key="language">Language</label>
                                        <label class="mode-switch">
                                            <input type="checkbox" id="languageToggle">
                                            <span class="mode-slider"></span>
                                        </label>
                                        <div class="mode-icons"><span>EN</span><span>HI</span></div>
                                    </div>
                                    <div class="mode-toggle">
                                        <label for="notificationToggle" data-lang-key="notifications">Notifications</label>
                                        <label class="mode-switch">
                                            <input type="checkbox" id="notificationToggle">
                                            <span class="mode-slider"></span>
                                        </label>
                                         <div class="mode-icons"><i class="fas fa-bell-slash"></i><i class="fas fa-bell"></i></div>
                                    </div>
                                    <div class="mode-toggle">
                                        <label for="soundToggle" data-lang-key="sound">Sound</label>
                                        <label class="mode-switch">
                                            <input type="checkbox" id="soundToggle">
                                            <span class="mode-slider"></span>
                                        </label>
                                        <div class="mode-icons"><i class="fas fa-volume-mute"></i><i class="fas fa-volume-up"></i></div>
                                    </div>
                                    <div class="mode-toggle">
                                        <label for="predictionModeToggle" data-lang-key="prediction_mode">Prediction Mode</label>
                                        <label class="mode-switch">
                                            <input type="checkbox" id="predictionModeToggle">
                                            <span class="mode-slider"></span>
                                        </label>
                                        <div class="mode-icons"><span>Normal</span><span>Advanced</span></div>
                                    </div>
                                    <button id="resetSettingsBtn" class="w-full secondary-btn mt-2" onclick="alphaX_resetSettings()">
                                        <i class="fas fa-undo mr-2"></i><span data-lang-key="reset_settings">Reset Settings</span>
                                    </button>
                                </div>
                            </div>
                            <hr class="border-card-border-color my-6">
                            <div>
                                <h3 class="text-xl font-semibold mb-3 text-accent-primary" data-lang-key="more_info_title">More Information</h3>
                                <div class="space-y-3">
                                    <button class="w-full secondary-btn" onclick="alphaX_openVideoPopup()">
                                        <i class="fas fa-play-circle mr-2"></i><span data-lang-key="how_to_use">How To Use</span> (<span data-lang-key="watch_video">Watch Video</span>)
                                    </button>
                                </div>
                            </div>
                         </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="navigation">
            <ul>
                <li class="active">
                    <a href="#" data-section="homeSection">
                        <span class="icon"><ion-icon name="home-outline"></ion-icon></span>
                        <span class="text" data-lang-key="home">Home</span>
                    </a>
                </li>
                <li>
                    <a href="#" data-section="historySection">
                        <span class="icon"><ion-icon name="time-outline"></ion-icon></span>
                        <span class="text" data-lang-key="history">History</span>
                    </a>
                </li>
                <li>
                    <a href="#" data-section="statsSection">
                        <span class="icon"><ion-icon name="bar-chart-outline"></ion-icon></span>
                        <span class="text" data-lang-key="stats">Stats</span>
                    </a>
                </li>
                <li>
                    <a href="#" data-section="aboutSection">
                        <span class="icon"><ion-icon name="information-circle-outline"></ion-icon></span>
                        <span class="text" data-lang-key="about">About</span>
                    </a>
                </li>
                </ul>
        </div>

        <div id="videoPopup" class="popup">
            <h3 data-lang-key="how_to_use_aura_x_ai">How To Use ALPHA X AI</h3>
            <div class="video-container">
                <iframe id="youtubeVideo" width="560" height="315" src="" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            </div>
            <div class="button-group mt-4">
                <button class="secondary-btn" onclick="alphaX_closeVideoPopup()"><i class="fas fa-times mr-2"></i><span data-lang-key="cancel">Close</span></button>
            </div>
        </div>

        <div id="confirmModal" class="modal">
            <h3 data-lang-key="confirm_action">Confirm Action</h3>
            <p id="modalMessage">Are you sure?</p>
            <div class="button-group">
                <button id="cancelModalBtn" class="secondary-btn"><i class="fas fa-times mr-2"></i><span data-lang-key="cancel">Cancel</span></button>
                <button id="confirmModalBtn" class="primary-btn"><i class="fas fa-check mr-2"></i><span data-lang-key="confirm">Confirm</span></button>
            </div>
        </div>

        <div id="streakBreakPopup" class="popup">
            <h3><i class="fas fa-fire-alt text-orange-400 mr-2"></i><span data-lang-key="streak_alert_title">Win Streak Alert!</span></h3>
            <p id="streakBreakMessage">You're on a 7-win streak! Consider taking a break?</p>
            <div class="button-group">
                 <button class="primary-btn" onclick="alphaX_closeStreakBreakPopupAndPause(20)"><i class="fas fa-pause mr-2"></i><span data-lang-key="pause_for_20_min">Pause (20min)</span></button>
                 <button id="cancelStreakModalBtn" class="secondary-btn"><i class="fas fa-play mr-2"></i><span data-lang-key="continue_predicting">Keep Going</span></button>
            </div>
        </div>
        
        <div id="predictionDisabledPopup" class="popup">
            <h3><i class="fas fa-stopwatch text-warning-color mr-2"></i><span data-lang-key="prediction_disabled_title">Predictions Paused</span></h3>
            <p id="predictionDisabledReasonText" class="text-sm"></p>
            <div id="predictionDisabledTimer" class="my-4 text-2xl font-bold">00:00</div>
            <p class="text-xs text-text-light-secondary" data-lang-key="auto_resume_notice">Predictions will resume automatically.</p>
        </div>


    </div> <div id="loginToast" class="toast-login" style="display: none;">
        <span class="icon"></span>
        <p id="loginToastMessage" class="text-base"></p>
    </div>

    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>
    <script>
        // --- Firebase Configuration ---
        const firebaseConfig = {
            apiKey: "AIzaSyAV8WCu5kXbs85NtYiwiOtiAsYQ72SA27M", 
            authDomain: "aipredictor-cf4b8.firebaseapp.com",
            databaseURL: "https://aipredictor-cf4b8-default-rtdb.firebaseio.com",
            projectId: "aipredictor-cf4b8",
            storageBucket: "aipredictor-cf4b8.appspot.com",
            messagingSenderId: "1036472549306",
            appId: "1:1036472549306:web:dc3630c08d41f84369a783",
            measurementId: "G-0YR80TMFPX"
        };
        firebase.initializeApp(firebaseConfig);
        const db = firebase.database();

        // --- Auth State & Config for New Login ---
        const USER_DEVICE_ID_STORAGE_KEY_ALPHAX = 'userGeneratedDeviceId_AlphaXAI_V3';
        const TELEGRAM_USERNAME_STORAGE_KEY_ALPHAX = 'telegramUsername_AlphaXAI_V3';
        const PREDICTOR_LOGGED_IN_KEY_ALPHAX = 'predictorLoggedIn_AlphaXAI_V3';
        let currentDeviceIdAlphaX = null;
        let approvalCheckIntervalAlphaX = null;
        const APPROVAL_CHECK_INTERVAL_MS_ALPHAX = 5000;


        // --- Global state for predictor app ---
        let alphaX_currentLanguage = localStorage.getItem('alphaXAiLanguage') || 'en';
        let alphaX_isSoundEnabled = localStorage.getItem('alphaXAiSound') === null ? true : localStorage.getItem('alphaXAiSound') === 'true';
        let alphaX_isNotificationsEnabled = localStorage.getItem('alphaXAiNotifications') === 'true' || false;
        let alphaX_isAdvancedModeActive = localStorage.getItem('alphaXAiPredictionMode') === null ? true : localStorage.getItem('alphaXAiPredictionMode') === 'advanced';
        let alphaX_lastFetchedPeriod = null;
        let alphaX_appHistory = JSON.parse(localStorage.getItem('alphaXAiHistory_v2')) || []; // Changed key for new structure if needed
        let alphaX_currentStreak = parseInt(localStorage.getItem('alphaXCurrentStreak')) || 0;
        
        // Prediction disabling states
        let alphaX_isPredictionSystemDisabled = false; // Master disable flag
        let alphaX_predictionSystemDisabledUntil = 0; // Timestamp
        let alphaX_predictionSystemDisableReason = ""; // Reason for display
        let alphaX_predictionSystemDisableTimerInterval = null; // Interval ID for UI timer
        const LAST_HISTORY_CLEAR_TIMESTAMP_KEY = 'alphaXLastHistoryClear_v2';
        const WIN_STREAK_DISABLE_MINUTES = 20;
        const BAD_TREND_DISABLE_MINUTES = 20;
        const ANTI_MANIPULATION_DISABLE_MINUTES = 20;


        let alphaX_signalPerformance = JSON.parse(localStorage.getItem('alphaXAiSignalPerformance_v2')) || {};
        let alphaX_isMaintenanceModeActive = false; 

        // DOM Elements for predictor app
        const appContainerEl = document.getElementById('appContainer'); // Added for blur effect
        const alphaX_currentPeriodEl = document.getElementById('currentPeriod');
        const alphaX_currentResultEl = document.getElementById('currentResult');
        const alphaX_confidenceFillEl = document.getElementById('confidenceFill');
        const alphaX_confidenceTextEl = document.getElementById('confidenceText');
        const alphaX_mostFrequentBigSmallEl = document.getElementById('mostFrequentBigSmall');
        const alphaX_leastFrequentBigSmallEl = document.getElementById('leastFrequentBigSmall');
        const alphaX_winRateEl = document.getElementById('winRate');
        const alphaX_totalWinBetsEl = document.getElementById('totalWinBets');
        const alphaX_totalLossBetsEl = document.getElementById('totalLossBets');
        const alphaX_serverStatusEl = document.getElementById('serverStatus');
        const alphaX_serverStatusIndicator = document.getElementById('serverStatusIndicator');
        const alphaX_historyContainer = document.getElementById('history');
        const alphaX_statsTotalWinsEl = document.getElementById('statsTotalWins');
        const alphaX_statsTotalLossesEl = document.getElementById('statsTotalLosses');
        const alphaX_statsWinRateEl = document.getElementById('statsWinRate');
        const alphaX_currentStreakEl = document.getElementById('currentStreak');
        const alphaX_lastFiveActualsEl = document.getElementById('lastFiveActuals');
        const alphaX_videoPopupEl = document.getElementById('videoPopup');
        const alphaX_youtubeVideoEl = document.getElementById('youtubeVideo');
        const alphaX_confirmModalEl = document.getElementById('confirmModal');
        const alphaX_modalMessageEl = document.getElementById('modalMessage');
        const alphaX_streakBreakPopupEl = document.getElementById('streakBreakPopup');
        const alphaX_streakBreakMessageEl = document.getElementById('streakBreakMessage');
        const alphaX_badTrendIndicatorEl = document.getElementById('badTrendIndicator'); // Banner
        const alphaX_badTrendMessageTextEl = document.getElementById('badTrendMessage'); // Text in banner
        
        // Prediction Disabled Timer Popup Elements
        const alphaX_predictionDisabledPopupEl = document.getElementById('predictionDisabledPopup');
        const alphaX_predictionDisabledReasonTextEl = document.getElementById('predictionDisabledReasonText');
        const alphaX_predictionDisabledTimerEl = document.getElementById('predictionDisabledTimer');


        const alphaX_translations = {
             en: {
                period: "Period", prediction: "Prediction", confidence: "Confidence",
                analysis_dashboard: "Analysis Dashboard", most_frequent_bs: "Most Frequent (B/S)",
                least_frequent_bs: "Least Frequent (B/S)", win_rate: "Win Rate", wins: "Wins", losses: "Losses",
                server_status: "Server Status", connected: "Connected", disconnected: "Disconnected", under_maintenance: "Under Maintenance",
                history: "History", delete: "Delete All", statistics: "Statistics", total_wins: "Total Wins",
                total_losses: "Total Losses", current_streak: "Current Streak", last_five_actuals: "Last 5 Actuals",
                about: "About", home: "Home", stats: "Stats",
                about_aura_x_ai: "About ALPHA X AI",
                predictor_intro_title: "Our Prediction Engine",
                predictor_intro_p1: "ALPHA X AI employs a sophisticated prediction engine designed to analyze trends and patterns from historical data. Our goal is to provide insightful predictions, but it's important to remember that these are based on statistical analysis and not guarantees of future outcomes.",
                predictor_intro_p2: "The system uses an advanced multi-model approach, combining numerous analytical techniques to enhance accuracy and adapt to changing conditions. This version incorporates enhanced pattern recognition, transitional analysis, and weighted historical data to provide more nuanced predictions.",
                how_it_works_title: "How It Works (Advanced)",
                how_it_works_subtitle_adv: "Our engine integrates a diverse range of analytical approaches, from statistical methods to conceptual AI-driven techniques, to achieve robust predictions:",
                // New Engine Keys
                engine_sum_range: "<strong>Sum Range Analyzer:</strong> Examines historical distribution and probable range of the total sum of drawn numbers.",
                engine_high_low_ratio: "<strong>High/Low Ratio Analyzer:</strong> Tracks historical frequency of combinations having more 'high' vs 'low' numbers.",
                engine_sum_freq_tracker: "<strong>Sum Frequency Tracker:</strong> Counts how often the overall sum has fallen into predefined 'big' or 'small' categories.",
                engine_num_dist: "<strong>Number Distribution Analyzer:</strong> Studies how drawn numbers spread across various segments of the entire number range.",
                engine_consecutive_num: "<strong>Consecutive Number Analyzer:</strong> Identifies patterns in occurrence of consecutive numbers within winning draws.",
                engine_gap_analysis: "<strong>Gap Analysis Engine:</strong> Analyzes numerical differences (gaps) between sorted numbers in winning combinations.",
                engine_machine_bias: "<strong>Drawing Machine Bias Analyzer (Conceptual):</strong> Attempts to detect subtle biases in physical lottery equipment (highly speculative).",
                engine_ml: "<strong>Machine Learning (ML) Engine (Conceptual):</strong> Uses AI algorithms (e.g., Neural Networks) to find complex patterns in historical data.",
                engine_monte_carlo: "<strong>Monte Carlo Simulation Engine (Conceptual):</strong> Generates simulated draws to determine statistical probabilities.",
                engine_markov_chain: "<strong>Markov Chain Analysis Engine:</strong> Models sequences of states (e.g., 'big' sum followed by 'small' sum) for transition probabilities.",
                engine_ga: "<strong>Genetic Algorithm (GA) Engine (Conceptual):</strong> Employs evolutionary algorithms to 'evolve' rules that best predict past outcomes.",
                engine_fractal: "<strong>Fractal Analysis Engine (Conceptual):</strong> Explores time series for self-similar patterns or long-term memory.",
                engine_chaos_theory: "<strong>Chaos Theory / Non-linear Dynamics Engine (Conceptual):</strong> Applies mathematical tools to seek deterministic but chaotic behavior.",
                engine_wavelet: "<strong>Wavelet Analysis Engine (Conceptual):</strong> Decomposes time series into frequency components to reveal hidden periodicities.",
                engine_info_theory: "<strong>Information Theory (Entropy) Engine:</strong> Quantifies randomness/unpredictability of results using measures like Shannon entropy.",
                engine_graph_theory: "<strong>Graph Theory / Network Analysis Engine (Conceptual):</strong> Represents relationships between numbers/states as a network to find structural patterns.",
                engine_bayesian: "<strong>Bayesian Inference Engine (Conceptual):</strong> Uses Bayesian methods to update outcome probabilities based on observed data.",
                engine_copula: "<strong>Copula-Based Modeling Engine (Conceptual):</strong> Models complex dependence structure between multiple random variables.",
                engine_rl: "<strong>Reinforcement Learning (RL) Engine (Conceptual):</strong> An AI agent could theoretically learn by 'rewards' from past predictions (highly theoretical for random events).",
                engine_tda: "<strong>Topological Data Analysis (TDA) Engine (Conceptual):</strong> Uses topological tools to find 'shapes' in high-dimensional data.",
                engine_rqa: "<strong>Recurrence Quantification Analysis (RQA) Engine (Conceptual):</strong> Identifies recurring patterns in time series of outcomes.",
                engine_hmm: "<strong>Hidden Markov Model (HMM) Engine (Conceptual):</strong> Infers unobserved states influencing outcomes.",
                engine_optimal_transport: "<strong>Optimal Transport / Wasserstein Distance Engine (Conceptual):</strong> Measures dissimilarity between probability distributions.",
                // Original "How it works" points
                how_it_works_li1_adv: "<strong>Multi-Period Frequency Analysis:</strong> Tracks \"BIG\" vs \"SMALL\" occurrences over short, medium, and long-term windows.",
                how_it_works_li2_adv: "<strong>Transition Matrix Analysis:</strong> Calculates probabilities of B->S, S->B, B->B, S->S transitions.",
                how_it_works_li3_adv: "<strong>Advanced Pattern Matching:</strong> Identifies recurring sequences (e.g., BSBS, BBSS) and alternating trends.",
                how_it_works_li4_adv: "<strong>Streak Dynamics:</strong> Analyzes current and historical win/loss streaks for both outcomes, assessing continuation or reversal likelihood.",
                how_it_works_li11_adv: "<strong>Relative Strength Index (RSI) Analysis:</strong> Measures the speed and change of recent number movements (0-9) to identify potential overbought (predict SMALL) or oversold (predict BIG) conditions.",
                how_it_works_li_macd: "<strong>Moving Average Convergence Divergence (MACD) Analyzer:</strong> Tracks the relationship between two moving averages of numerical outcomes to identify momentum shifts.",
                how_it_works_li_bollinger: "<strong>Bollinger Bands Analyzer:</strong> Uses standard deviation bands around a moving average to assess volatility and potential overextension.",
                how_it_works_li_inter_signal: "<strong>Inter-Signal Confirmation Engine:</strong> Assesses the level of agreement among various analytical engines to adjust overall confidence.",
                how_it_works_li10_adv: "<strong>Adaptive Trend Protection:</strong> Automatically disables or flags predictions during highly unstable or unfavorable trends.",
                important_note_title: "Important Note",
                important_note_p1: "All predictions provided by ALPHA X AI are for informational and entertainment purposes only. Past performance is not indicative of future results. Please use this information responsibly. Predictions are based on the device's local history and may vary if histories differ across devices.",
                meet_the_team_title: "Meet The Team", owner_info: "<strong>Owner/Developer:</strong> @ALPHAXAIWEB", owner_telegram: "Telegram Profile",
                general_settings_title: "General Settings", more_info_title: "More Information", status: "Status",
                language: "Language", notifications: "Notifications", sound: "Sound", reset_settings: "Reset Settings",
                reset: "Reset", prediction_mode: "Prediction Mode", how_to_use: "How To Use", watch_video: "Watch Video",
                privacy_policy: "Privacy Policy", read_more: "Read More", how_to_use_aura_x_ai: "How To Use ALPHA X AI",
                confirm_action: "Confirm Action", cancel: "Cancel", confirm: "Confirm", pending: "Pending",
                win: "Win", loss: "Loss", delete_item_confirm: "Are you sure you want to delete this history item?",
                delete_all_confirm: "Are you sure you want to delete all history items? This will pause predictions for 20 minutes.",
                reset_settings_confirm: "Are you sure you want to reset all settings to default?",
                api_error: "API Error. Please try again later.", fetching_data: "Fetching data...",
                streak_alert_title: "Win Streak Alert", trend_alert: "Trend Alert", 
                pause_predictions: "Pause Predictions", disable_predictions: "Disable Predictions", 
                continue_predicting: "Keep Going", continue_predicting_anyway: "Continue Anyway",
                predictions_paused: "Predictions Paused", predictions_disabled: "Predictions Disabled",
                resume_predictions: "Resume Predictions",
                unstable_trend_detected: "Unstable trend detected. Predictions paused for 20 minutes.",
                bad_trend_popup_message: "The current trend analysis shows unstable patterns. Predictions are paused for 20 minutes to protect against potential losses.",
                win_streak_popup_message: "Amazing! You're on a {STREAK_COUNT}-win streak. Predictions will pause for 20 minutes to maintain stability.",
                system_integrity_pause: "System integrity check. Predictions paused for 20 minutes.",
                trend_will_auto_resume: "Predictions will automatically resume when the timer ends.",
                no_history: "No history yet.",
                prediction_disabled_title: "Predictions Paused",
                auto_resume_notice: "Predictions will resume automatically.",
                pause_for_20_min: "Pause (20min)"
            },
            hi: { // Hindi translations - abbreviated for brevity, ensure full translation for production
                period: "", prediction: "", confidence: "",
                analysis_dashboard: " ", most_frequent_bs: "  (/)",
                least_frequent_bs: "    (/)", win_rate: " ", wins: "", losses: "",
                server_status: " ", connected: " ", disconnected: "  ", under_maintenance: "  ",
                history: "", delete: "  ", statistics: "", total_wins: " ",
                total_losses: " ", current_streak: " ", last_five_actuals: " 5 ",
                about: "", home: "", stats: "",
                about_aura_x_ai: "     ",
                predictor_intro_title: "  ",
                predictor_intro_p1: "                                 ,                     ",
                predictor_intro_p2: "         -     ,                             ,          ",
                how_it_works_title: "     ()",
                how_it_works_subtitle_adv: "             -         :",
                engine_sum_range: "<strong>  :</strong>                ",
                engine_high_low_ratio: "<strong>/  :</strong> ''  ''          ",
                engine_sum_freq_tracker: "<strong>  :</strong>          ''  ''    ",
                engine_num_dist: "<strong>  :</strong>                  ",
                engine_consecutive_num: "<strong>  :</strong>              ",
                engine_gap_analysis: "<strong>  :</strong>           ()    ",
                engine_machine_bias: "<strong>    ():</strong>            ( )",
                engine_ml: "<strong>  ()  ():</strong>           (,  )    ",
                engine_monte_carlo: "<strong>    ():</strong>            ",
                engine_markov_chain: "<strong>   :</strong>        (, ''    '' )    ",
                engine_ga: "<strong>  ()  ():</strong>           ''         ",
                engine_fractal: "<strong>   ():</strong> -            ",
                engine_chaos_theory: "<strong>  / -   ():</strong>              ",
                engine_wavelet: "<strong>   ():</strong>                 ",
                engine_info_theory: "<strong>  () :</strong>          /   ",
                engine_graph_theory: "<strong>  /    ():</strong>      /           ",
                engine_bayesian: "<strong>   ():</strong>                   ",
                engine_copula: "<strong>-   ():</strong>            ",
                engine_rl: "<strong>  ()  ():</strong>          ''     (     )",
                engine_tda: "<strong>   ()  ():</strong> -   ''          ",
                engine_rqa: "<strong>   ()  ():</strong>           ",
                engine_hmm: "<strong>   ()  ():</strong>           ",
                engine_optimal_transport: "<strong>  /    ():</strong>        ",
                how_it_works_li1_adv: "<strong>-  :</strong> ,        \"\"  \"\"     ",
                how_it_works_li2_adv: "<strong>  :</strong> B->S, S->B, B->B, S->S       ",
                how_it_works_li3_adv: "<strong>  :</strong>   (, BSBS, BBSS)       ",
                how_it_works_li4_adv: "<strong> :</strong>        /      ,         ",
                how_it_works_li11_adv: "<strong>   (RSI) :</strong>    (0-9)           (SMALL  )   (BIG  )      ",
                how_it_works_li_macd: "<strong>    (MACD) :</strong>                    ",
                how_it_works_li_bollinger: "<strong>  :</strong>                    ",
                how_it_works_li_inter_signal: "<strong>-  :</strong>                   ",
                how_it_works_li10_adv: "<strong>  :</strong>                 ",
                important_note_title: " ",
                important_note_p1: "                                                        ",
                meet_the_team_title: "  ", owner_info: "<strong>/:</strong> @ALPHAXAIWEB", owner_telegram: " ",
                general_settings_title: " ", more_info_title: " ", status: "",
                language: "", notifications: "", sound: "", reset_settings: "  ",
                reset: "", prediction_mode: " ", how_to_use: "  ", watch_video: " ",
                privacy_policy: " ", read_more: " ", how_to_use_aura_x_ai: "      ",
                confirm_action: "   ", cancel: " ", confirm: " ", pending: "",
                win: "", loss: "", delete_item_confirm: "           ?",
                delete_all_confirm: "          ?  20      ",
                reset_settings_confirm: "             ?",
                api_error: "     :  ", fetching_data: "     ...",
                streak_alert_title: "   ", trend_alert: " ", 
                pause_predictions: " ", disable_predictions: "  ", 
                continue_predicting: " ", continue_predicting_anyway: "   ",
                predictions_paused: "    ", predictions_disabled: "     ",
                resume_predictions: "    ",
                unstable_trend_detected: "      20       ",
                bad_trend_popup_message: "              20       ",
                win_streak_popup_message: "!  {STREAK_COUNT}-           20     ",
                system_integrity_pause: "    20       ",
                trend_will_auto_resume: "            ",
                no_history: "     ",
                prediction_disabled_title: "  ",
                auto_resume_notice: "        ",
                pause_for_20_min: " (20)"
            }
        };

        // --- Page State Management (Consolidated) ---
        function showScreenAlphaX(screenId) {
            const page1 = document.getElementById('loginPage1AlphaX');
            const page2 = document.getElementById('loginPage2AlphaX');
            const app = document.getElementById('appContainer');
            const maintenance = document.getElementById('maintenanceContainer');

            if(page1) page1.classList.remove('active');
            if(page2) page2.classList.remove('active');
            if(app) app.classList.remove('active');
            if(maintenance) maintenance.classList.remove('active');

            const targetScreen = document.getElementById(screenId);
            if (targetScreen) {
                targetScreen.classList.add('active');
                gsap.fromTo(targetScreen, {opacity: 0, y: 15}, {opacity: 1, y: 0, duration: 0.4, ease: "power2.out"});
            }

            if (screenId === 'appContainer') {
                document.body.style.justifyContent = 'flex-start';
                document.body.style.alignItems = 'stretch';
            } else {
                document.body.style.justifyContent = 'center';
                document.body.style.alignItems = 'center';
            }
        }

        function showMaintenancePageAlphaX(message) {
            const msgEl = document.getElementById('maintenanceMessage');
            if (msgEl) {
                msgEl.textContent = message || "The platform is currently under maintenance. Please try again later.";
            }
            showScreenAlphaX('maintenanceContainer');
        }

        // --- Device ID Generation for New Login ---
        function generateUniqueIdAlphaX() {
            return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
                (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
            );
        }

        function getOrGenerateUserDeviceIdAlphaX() {
            let deviceId = localStorage.getItem(USER_DEVICE_ID_STORAGE_KEY_ALPHAX);
            if (!deviceId) {
                deviceId = "AX-USER-" + generateUniqueIdAlphaX().substring(0,10).toUpperCase();
                localStorage.setItem(USER_DEVICE_ID_STORAGE_KEY_ALPHAX, deviceId);
            }
            currentDeviceIdAlphaX = deviceId;
            const deviceIdDisplayEl = document.getElementById('displayedDeviceIdAlphaX');
            if (deviceIdDisplayEl) deviceIdDisplayEl.textContent = deviceId;
            return deviceId;
        }

        // --- Login Flow Functions ---
        async function handleSubmitUsernameAlphaX() {
            const usernameInput = document.getElementById('telegramUsernameInputAlphaX');
            const errorEl = document.getElementById('usernameErrorAlphaX');
            const submitBtn = document.getElementById('submitUsernameBtnAlphaX');

            if(!usernameInput || !errorEl || !submitBtn) {
                console.error("handleSubmitUsernameAlphaX: Critical DOM elements missing.");
                return;
            }

            const username = usernameInput.value.trim().replace(/^@/, '');
            if (!username || !/^[a-zA-Z0-9_]{5,32}$/.test(username)) {
                errorEl.textContent = 'Please enter a valid Telegram username (5-32 chars, a-z, 0-9, _).';
                errorEl.style.display = 'block';
                return;
            }
            errorEl.style.display = 'none';
            submitBtn.disabled = true;
            submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Processing...';

            currentDeviceIdAlphaX = getOrGenerateUserDeviceIdAlphaX();

            try {
                const deviceRef = db.ref(`alphax_user_access_requests/${currentDeviceIdAlphaX}`);
                const snapshot = await deviceRef.get();
                const deviceData = snapshot.val();

                let updates = {
                    telegramUsername: username,
                    requestedAt: firebase.database.ServerValue.TIMESTAMP,
                    deviceId: currentDeviceIdAlphaX
                };

                if (deviceData && deviceData.telegramUsername && deviceData.telegramUsername !== username) {
                    updates.status = 'pending'; // Reset status if username changes for existing device ID
                    updates.approvedAt = null;
                    updates.expiryTimestamp = null;
                    updates.validityValue = null;
                    updates.validityUnit = null;
                    console.log(`AlphaX: Username changed for Device ID ${currentDeviceIdAlphaX}. Resetting approval.`);
                    localStorage.removeItem(PREDICTOR_LOGGED_IN_KEY_ALPHAX); // Log out if username changes
                     // Trigger anti-manipulation pause if username changes for an existing device
                    alphaX_disablePredictionSystem(
                        alphaX_translations[alphaX_currentLanguage].system_integrity_pause || "System integrity check due to user change.",
                        ANTI_MANIPULATION_DISABLE_MINUTES,
                        true 
                    );
                } else if (!deviceData) {
                    updates.status = 'pending';
                }


                await deviceRef.update(updates);

                localStorage.setItem(TELEGRAM_USERNAME_STORAGE_KEY_ALPHAX, username);
                console.log(`AlphaX Device ID ${currentDeviceIdAlphaX} with username ${username} registered/updated.`);

                showScreenAlphaX('loginPage2AlphaX');
                updateApprovalStatusUIAlphaX(updates.status || deviceData?.status || 'pending');
                startApprovalCheckAlphaX();
            } catch (error) {
                console.error("Error submitting AlphaX username:", error);
                if(errorEl) {
                    errorEl.textContent = 'Failed to submit. Check connection or try again.';
                    errorEl.style.display = 'block';
                }
            } finally {
                if(submitBtn) {
                    submitBtn.disabled = false;
                    submitBtn.innerHTML = 'Continue';
                }
            }
        }

        function copyCurrentDeviceIdAlphaX() {
            const deviceIdDisplayEl = document.getElementById('displayedDeviceIdAlphaX');
            const feedbackEl = document.getElementById('copyFeedbackAlphaX');
            if(!deviceIdDisplayEl || !feedbackEl) return;

            const deviceIdToCopy = deviceIdDisplayEl.textContent;
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(deviceIdToCopy).then(() => {
                    feedbackEl.classList.add('show');
                    setTimeout(() => feedbackEl.classList.remove('show'), 2000);
                }).catch(err => { console.error('Failed to copy device ID:', err); alphaX_showLoginToast('Failed to copy Device ID.', 'error'); });
            } else { // Fallback for older browsers
                const textArea = document.createElement("textarea"); textArea.value = deviceIdToCopy; document.body.appendChild(textArea);
                textArea.select(); document.execCommand('copy'); document.body.removeChild(textArea);
                feedbackEl.classList.add('show'); setTimeout(() => feedbackEl.classList.remove('show'), 2000);
            }
        }

        function handleLogoutAlphaX(showLoginPage1 = true) {
            localStorage.removeItem(PREDICTOR_LOGGED_IN_KEY_ALPHAX);
            if (approvalCheckIntervalAlphaX) clearInterval(approvalCheckIntervalAlphaX);
            approvalCheckIntervalAlphaX = null;
            
            // Trigger anti-manipulation pause on logout
             alphaX_disablePredictionSystem(
                alphaX_translations[alphaX_currentLanguage].system_integrity_pause || "System integrity check after logout.",
                ANTI_MANIPULATION_DISABLE_MINUTES,
                true 
            );

            if (showLoginPage1) {
                const usernameInput = document.getElementById('telegramUsernameInputAlphaX');
                if(usernameInput) usernameInput.value = localStorage.getItem(TELEGRAM_USERNAME_STORAGE_KEY_ALPHAX) || '';
                showScreenAlphaX('loginPage1AlphaX');
            } else {
                // If app is active, redirect to login page 1.
                const appContainerEl = document.getElementById('appContainer');
                if (appContainerEl && appContainerEl.classList.contains('active')) {
                    showScreenAlphaX('loginPage1AlphaX');
                }
            }
            console.log("User logged out from AlphaX.");
            alphaX_showLoginToast('Successfully logged out.', 'info');
        }

        function updateApprovalStatusUIAlphaX(status, message = '') {
            const container = document.getElementById('approvalStatusContainerAlphaX');
            if (!container) return;

            container.classList.remove('status-pending-alphax', 'status-approved-alphax', 'status-rejected-alphax', 'status-expired-alphax', 'status-info-alphax');
            let iconHtml = '<i class="fas fa-spinner fa-spin mr-2"></i>';
            let fullMessage = message || 'Checking status...';

            switch(status) {
                case 'pending':
                    container.classList.add('status-pending-alphax');
                    iconHtml = '<i class="fas fa-hourglass-half mr-2"></i>';
                    fullMessage = message || 'Waiting for admin approval. Please share your Device ID with the admin.';
                    break;
                case 'approved':
                    container.classList.add('status-approved-alphax');
                    iconHtml = `
                        <span class="tick-animation-alphax mr-2">
                            <svg viewBox="0 0 52 52">
                                <circle class="tick-circle" cx="26" cy="26" r="25"/>
                                <path class="tick-path" d="M14.1 27.2l7.1 7.2 16.7-16.8"/>
                            </svg>
                        </span>`;
                    fullMessage = message || 'Access Approved! Redirecting to predictor...';
                    break;
                case 'rejected':
                    container.classList.add('status-rejected-alphax');
                    iconHtml = '<i class="fas fa-times-circle mr-2"></i>';
                    fullMessage = message || 'Access Denied. Please contact admin for assistance.';
                    break;
                case 'expired':
                    container.classList.add('status-expired-alphax');
                    iconHtml = '<i class="fas fa-clock mr-2"></i>';
                    fullMessage = message || 'Access Expired. Please request access again.';
                    break;
                default:
                    container.classList.add('status-info-alphax');
                    break;
            }
            container.innerHTML = `${iconHtml} ${fullMessage}`;
        }

        function startApprovalCheckAlphaX() {
            if (approvalCheckIntervalAlphaX) clearInterval(approvalCheckIntervalAlphaX);

            const check = async () => {
                if (!currentDeviceIdAlphaX) {
                    currentDeviceIdAlphaX = getOrGenerateUserDeviceIdAlphaX();
                    if (!currentDeviceIdAlphaX) return; // Should not happen if logic is correct
                }
                try {
                    const maintenanceStatusSnapshot = await db.ref("alphax_maintenanceStatus/status").get();
                    const isMaintenanceActive = maintenanceStatusSnapshot.val() === true;

                    if (isMaintenanceActive) {
                        alphaX_isMaintenanceModeActive = true; // Set global flag
                        const maintenanceMessageSnapshot = await db.ref("alphax_maintenanceStatus/message").get();
                        const message = maintenanceMessageSnapshot.val() || "ALPHA X AI is currently under maintenance.";
                        showMaintenancePageAlphaX(message);
                        if (approvalCheckIntervalAlphaX) clearInterval(approvalCheckIntervalAlphaX);
                        // Update UI elements in appContainer if it's somehow visible
                        if (document.getElementById('appContainer').classList.contains('active')) {
                             if(alphaX_serverStatusEl) alphaX_serverStatusEl.textContent = alphaX_translations[alphaX_currentLanguage]?.under_maintenance || "Under Maintenance";
                             if(alphaX_serverStatusIndicator) alphaX_serverStatusIndicator.className = 'w-3 h-3 bg-warning-color rounded-full';
                             if(alphaX_currentResultEl) alphaX_currentResultEl.textContent = alphaX_translations[alphaX_currentLanguage]?.under_maintenance || "Under Maintenance";
                        }
                        return;
                    } else {
                        alphaX_isMaintenanceModeActive = false; // Clear flag
                    }

                    const deviceSnapshot = await db.ref(`alphax_user_access_requests/${currentDeviceIdAlphaX}`).get();
                    const deviceData = deviceSnapshot.val();

                    if (deviceData) {
                        const storedUsername = localStorage.getItem(TELEGRAM_USERNAME_STORAGE_KEY_ALPHAX);
                        // If username in DB doesn't match stored, treat as pending re-verification
                        if (deviceData.telegramUsername !== storedUsername) {
                            updateApprovalStatusUIAlphaX('pending', 'Username mismatch. Please re-submit or contact admin.');
                            // Optionally, could auto-logout here or force re-submission of username
                            return;
                        }

                        if (deviceData.status === 'approved') {
                            if (deviceData.expiryTimestamp && Date.now() > deviceData.expiryTimestamp) {
                                updateApprovalStatusUIAlphaX('expired', 'Access Expired. Please request access again.');
                                handleLogoutAlphaX(false); // Logout but don't necessarily go to page 1 if already on page 2
                            } else {
                                clearInterval(approvalCheckIntervalAlphaX);
                                approvalCheckIntervalAlphaX = null;
                                updateApprovalStatusUIAlphaX('approved');
                                localStorage.setItem(PREDICTOR_LOGGED_IN_KEY_ALPHAX, 'true');
                                localStorage.setItem(TELEGRAM_USERNAME_STORAGE_KEY_ALPHAX, deviceData.telegramUsername); // Ensure it's current
                                alphaX_showLoginToast('Access Approved! Welcome!', 'success');
                                
                                // Anti-manipulation check on successful login
                                const lastClearTime = parseInt(localStorage.getItem(LAST_HISTORY_CLEAR_TIMESTAMP_KEY)) || 0;
                                if (alphaX_appHistory.length === 0 && (Date.now() - lastClearTime < 60 * 60 * 1000)) { // If history cleared within last hour
                                    alphaX_disablePredictionSystem(
                                        alphaX_translations[alphaX_currentLanguage].system_integrity_pause || "System integrity check after data reset.",
                                        ANTI_MANIPULATION_DISABLE_MINUTES,
                                        true
                                    );
                                }

                                setTimeout(() => {
                                    showScreenAlphaX('appContainer');
                                    initializeAppPredictor();
                                }, 1500);
                            }
                        } else if (deviceData.status === 'rejected') {
                            updateApprovalStatusUIAlphaX('rejected');
                        } else if (deviceData.status === 'pending') {
                             updateApprovalStatusUIAlphaX('pending');
                        } else { // Unknown status
                            updateApprovalStatusUIAlphaX('info', 'Unknown status. Contact admin.');
                        }
                    } else { // Device not found in DB
                        updateApprovalStatusUIAlphaX('pending', 'Device not registered. Submit username on previous page.');
                    }
                } catch (error) {
                    console.error("Error checking AlphaX approval status:", error);
                    updateApprovalStatusUIAlphaX('info', 'Error checking status. Retrying...');
                }
            };

            check(); // Initial check
            approvalCheckIntervalAlphaX = setInterval(check, APPROVAL_CHECK_INTERVAL_MS_ALPHAX);
        }

        function alphaX_showLoginToast(message, type = 'info') {
            const toastEl = document.getElementById('loginToast');
            const messageEl = document.getElementById('loginToastMessage');
            const iconEl = toastEl.querySelector('.icon');

            if (!toastEl || !messageEl || !iconEl) return;

            messageEl.textContent = message;
            iconEl.className = 'icon'; // Reset classes
            if (type === 'success') {
                iconEl.classList.add('fas', 'fa-check-circle', 'success');
            } else if (type === 'error') {
                iconEl.classList.add('fas', 'fa-times-circle', 'error');
            } else { // info
                iconEl.classList.add('fas', 'fa-info-circle', 'info');
            }
            toastEl.style.display = 'flex';
            // GSAP animation for toast (optional, if you want to replace CSS animation)
            gsap.fromTo(toastEl, 
                { bottom: -60, opacity: 0 }, 
                { bottom: 90, opacity: 1, duration: 0.5, ease: "power2.out", 
                  onComplete: () => {
                      gsap.to(toastEl, { bottom: -60, opacity: 0, duration: 0.5, delay: 3, ease: "power2.in", onComplete: () => toastEl.style.display = 'none' });
                  }
                }
            );
        }


        // --- AlphaX Specific Predictor Functions ---

        // Prediction Disabling System
        function alphaX_disablePredictionSystem(reason, durationMinutes, isManipulationPenalty = false) {
            alphaX_isPredictionSystemDisabled = true;
            alphaX_predictionSystemDisabledUntil = Date.now() + durationMinutes * 60 * 1000;
            alphaX_predictionSystemDisableReason = reason;

            localStorage.setItem('alphaXPredictionSystemDisabled', 'true');
            localStorage.setItem('alphaXPredictionSystemDisabledUntil', alphaX_predictionSystemDisabledUntil.toString());
            localStorage.setItem('alphaXPredictionSystemDisableReason', reason);
            
            alphaX_updatePredictionDisabledUI();
            alphaX_playSound('alert');
        }

        function alphaX_checkAndResumePredictionSystem() {
            if (alphaX_isPredictionSystemDisabled && Date.now() >= alphaX_predictionSystemDisabledUntil) {
                alphaX_isPredictionSystemDisabled = false;
                alphaX_predictionSystemDisabledUntil = 0;
                alphaX_predictionSystemDisableReason = "";
                localStorage.removeItem('alphaXPredictionSystemDisabled');
                localStorage.removeItem('alphaXPredictionSystemDisabledUntil');
                localStorage.removeItem('alphaXPredictionSystemDisableReason');
                
                if(appContainerEl) appContainerEl.classList.remove('app-content-blurred'); // Remove blur
                if(alphaX_predictionSystemDisableTimerInterval) clearInterval(alphaX_predictionSystemDisableTimerInterval);
                alphaX_predictionSystemDisableTimerInterval = null;
                if(alphaX_predictionDisabledPopupEl) alphaX_predictionDisabledPopupEl.classList.remove('active');
                alphaX_hideBadTrendIndicatorUI(); // Also hide this if it was the cause
                alphaX_playSound('confirm');
                alphaX_fetchPredictionData(); // Attempt to fetch new data immediately
                return true; // Resumed
            }
            return false; // Still disabled or was not disabled
        }
        
        function alphaX_updatePredictionDisabledUI() {
            if (alphaX_isPredictionSystemDisabled) {
                if (appContainerEl) appContainerEl.classList.add('app-content-blurred'); // Add blur

                if (alphaX_predictionDisabledPopupEl && alphaX_predictionDisabledReasonTextEl && alphaX_predictionDisabledTimerEl) {
                    alphaX_predictionDisabledReasonTextEl.textContent = alphaX_predictionSystemDisableReason;
                    alphaX_predictionDisabledPopupEl.classList.add('active');

                    if (alphaX_predictionSystemDisableTimerInterval) clearInterval(alphaX_predictionSystemDisableTimerInterval);
                    
                    const updateTimer = () => {
                        const timeLeft = Math.max(0, alphaX_predictionSystemDisabledUntil - Date.now());
                        const minutes = Math.floor((timeLeft / (1000 * 60)) % 60);
                        const seconds = Math.floor((timeLeft / 1000) % 60);
                        if (alphaX_predictionDisabledTimerEl) alphaX_predictionDisabledTimerEl.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                        
                        if (timeLeft <= 0) {
                            clearInterval(alphaX_predictionSystemDisableTimerInterval);
                            alphaX_predictionSystemDisableTimerInterval = null;
                            alphaX_checkAndResumePredictionSystem();
                        }
                    };
                    updateTimer(); // Initial call
                    alphaX_predictionSystemDisableTimerInterval = setInterval(updateTimer, 1000);
                }
                // Update main UI elements
                if(alphaX_currentResultEl) alphaX_currentResultEl.textContent = alphaX_translations[alphaX_currentLanguage].predictions_disabled || "Predictions Disabled";
                if(alphaX_confidenceFillEl) alphaX_confidenceFillEl.style.width = "0%";
                if(alphaX_confidenceTextEl) alphaX_confidenceTextEl.textContent = "0%";
                alphaX_showBadTrendIndicatorUI(alphaX_predictionSystemDisableReason, alphaX_translations[alphaX_currentLanguage].trend_will_auto_resume);


            } else {
                if(appContainerEl) appContainerEl.classList.remove('app-content-blurred'); // Remove blur
                if(alphaX_predictionSystemDisableTimerInterval) clearInterval(alphaX_predictionSystemDisableTimerInterval);
                alphaX_predictionSystemDisableTimerInterval = null;
                if(alphaX_predictionDisabledPopupEl) alphaX_predictionDisabledPopupEl.classList.remove('active');
                alphaX_hideBadTrendIndicatorUI();
            }
        }


        function initializeAppPredictor() {
            console.log("Initializing AlphaX Predictor App Core Logic...");
            // Restore prediction disable state from localStorage
            alphaX_isPredictionSystemDisabled = localStorage.getItem('alphaXPredictionSystemDisabled') === 'true';
            alphaX_predictionSystemDisabledUntil = parseInt(localStorage.getItem('alphaXPredictionSystemDisabledUntil')) || 0;
            alphaX_predictionSystemDisableReason = localStorage.getItem('alphaXPredictionSystemDisableReason') || "";

            if (alphaX_isPredictionSystemDisabled) {
                if (Date.now() >= alphaX_predictionSystemDisabledUntil) {
                    alphaX_checkAndResumePredictionSystem(); // Try to resume if time is up
                } else {
                    alphaX_updatePredictionDisabledUI(); // Show existing timer and blur
                }
            }


            const langToggle = document.getElementById('languageToggle');
            if(langToggle) langToggle.checked = alphaX_currentLanguage === 'hi';

            const notifToggle = document.getElementById('notificationToggle');
            if(notifToggle) notifToggle.checked = alphaX_isNotificationsEnabled;

            const soundToggle = document.getElementById('soundToggle');
            if(soundToggle) soundToggle.checked = alphaX_isSoundEnabled;

            const predModeToggle = document.getElementById('predictionModeToggle');
            if(predModeToggle) predModeToggle.checked = alphaX_isAdvancedModeActive;


            alphaX_updateLanguage();
            alphaX_updateDashboardAndStats();
            alphaX_updateHistoryUI();


            alphaX_fetchPredictionData(); // Initial fetch
            setInterval(alphaX_fetchPredictionData, 10000); // Regular fetch

            if (alphaX_isNotificationsEnabled && Notification.permission !== 'granted') {
                Notification.requestPermission().then(permission => {
                    if (permission !== 'granted') {
                        alphaX_isNotificationsEnabled = false;
                        localStorage.setItem('alphaXAiNotifications', 'false');
                        if(notifToggle) notifToggle.checked = false;
                        alphaX_showLoginToast('Notifications permission denied.', 'info');
                    } else {
                         alphaX_showLoginToast('Notifications enabled!', 'success');
                    }
                });
            }

            // Navigation setup
            const alphaX_navItems = document.querySelectorAll('#appContainer .navigation ul li');
            const alphaX_sections = document.querySelectorAll('#appContainer .content-section');

            alphaX_navItems.forEach((item) => {
                item.addEventListener('click', (e) => {
                    e.preventDefault();
                    alphaX_navItems.forEach(nav => nav.classList.remove('active'));
                    item.classList.add('active');

                    const sectionId = item.querySelector('a').getAttribute('data-section');
                    alphaX_sections.forEach(section => section.classList.remove('active'));
                    const targetSection = document.getElementById(sectionId);
                    if (targetSection) {
                        targetSection.classList.add('active');
                        gsap.fromTo(targetSection, {opacity: 0, y: 10}, {opacity: 1, y: 0, duration: 0.3, ease: "power1.out"});
                    }
                     alphaX_playSound('navigate');
                });
            });
            // Ensure home is active by default
            const homeNavLi = document.querySelector('#appContainer .navigation ul li a[data-section="homeSection"]')?.closest('li');
            if (homeNavLi) {
                alphaX_navItems.forEach(li => li.classList.remove('active'));
                homeNavLi.classList.add('active');
            }
            const homeSection = document.getElementById('homeSection');
            if(homeSection && !homeSection.classList.contains('active')) {
                 alphaX_sections.forEach(section => section.classList.remove('active'));
                homeSection.classList.add('active');
            }
        }

        function alphaX_updateLanguage() {
            document.querySelectorAll('[data-lang-key]').forEach(element => {
                const key = element.getAttribute('data-lang-key');
                const translation = alphaX_translations[alphaX_currentLanguage]?.[key] || alphaX_translations['en']?.[key] || `[[${key}]]`; // Fallback to key
                if (translation) {
                    if (translation.includes('<') && translation.includes('>')) { // For HTML content
                        element.innerHTML = translation;
                    } else {
                        element.textContent = translation;
                    }
                }
            });
            // Specific updates if needed after general translation
            document.querySelectorAll('.history-item .watermark').forEach(wm => {
                wm.textContent = "ALPHA X AI"; // Keep watermark consistent
            });
            const serverIndicator = document.getElementById('serverStatusIndicator');
            const isConnected = serverIndicator && serverIndicator.classList.contains('bg-win-color');
            alphaX_updateServerStatusUI(isConnected); // Re-apply status text in new language
             alphaX_updatePredictionDisabledUI(); // Re-apply reason text in new language if popup is active
        }

        function alphaX_playSound(type) {
            if (!alphaX_isSoundEnabled) return;
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime); // Master volume

                switch(type) {
                    case 'win': oscillator.type = 'sine'; oscillator.frequency.setValueAtTime(600, audioContext.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.00001, audioContext.currentTime + 0.3); break;
                    case 'loss': oscillator.type = 'square'; oscillator.frequency.setValueAtTime(200, audioContext.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.00001, audioContext.currentTime + 0.3); break;
                    case 'notify': oscillator.type = 'triangle'; oscillator.frequency.setValueAtTime(440, audioContext.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.00001, audioContext.currentTime + 0.2); break;
                    case 'skipped': oscillator.type = 'sawtooth'; oscillator.frequency.setValueAtTime(300, audioContext.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.00001, audioContext.currentTime + 0.15); break;
                    case 'alert': // For more prominent alerts like disable timers
                        oscillator.type = 'square'; oscillator.frequency.setValueAtTime(800, audioContext.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.00001, audioContext.currentTime + 0.1);
                        setTimeout(() => { // Second beep for emphasis
                           const osc2 = audioContext.createOscillator(); const gain2 = audioContext.createGain();
                           osc2.connect(gain2); gain2.connect(audioContext.destination); gain2.gain.setValueAtTime(0.1, audioContext.currentTime);
                           osc2.type = 'square'; osc2.frequency.setValueAtTime(800, audioContext.currentTime); gain2.gain.exponentialRampToValueAtTime(0.00001, audioContext.currentTime + 0.1);
                           osc2.start(audioContext.currentTime + 0.15); osc2.stop(audioContext.currentTime + 0.25);
                        }, 150);
                        break;
                    case 'toggle': case 'navigate': case 'open': case 'close': case 'confirm': // Short UI interaction sounds
                        oscillator.type = 'sine'; oscillator.frequency.setValueAtTime(500, audioContext.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.00001, audioContext.currentTime + 0.1); break;
                    default: gainNode.gain.setValueAtTime(0, audioContext.currentTime); // No sound for unknown types
                }
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.5); // Max duration for any sound
            } catch (e) { console.warn("Web Audio API not supported or sound play failed:", e); }
        }

        function alphaX_getBigSmallFromActual(numStr) {
            if (numStr === null || typeof numStr === 'undefined') return null;
            const num = parseInt(numStr);
            if (isNaN(num)) return null;
            if (num >= 0 && num <= 4) return "SMALL";
            if (num >= 5 && num <= 9) return "BIG";
            return null; // Should not happen for 0-9
        }

        function alphaX_analyzeTrendStability(history) {
            if (!Array.isArray(history)) return { isStable: true, reason: "Invalid history data for stability check.", details: "" };
            const confirmedHistory = history.filter(p => p && (p.status === "Win" || p.status === "Loss") && typeof p.actual !== 'undefined' && p.actual !== null);
            if (confirmedHistory.length < 10) return { isStable: true, reason: "Not enough confirmed data for stability check.", details: `Need 10, have ${confirmedHistory.length}` };

            const recentResults = confirmedHistory.slice(0, 10).map(p => alphaX_getBigSmallFromActual(p.actual)).filter(r => r);
            if (recentResults.length < 10) return { isStable: true, reason: "Not enough valid B/S results for stability.", details: `Valid B/S: ${recentResults.length}` };

            // Check for extreme imbalance (e.g., 80% or more of one outcome in last 10)
            const bigCount = recentResults.filter(r => r === "BIG").length;
            const smallCount = recentResults.filter(r => r === "SMALL").length;
            if (bigCount >= 8 || smallCount >= 8) return { isStable: false, reason: alphaX_translations[alphaX_currentLanguage].unstable_trend_detected || "Extreme recent imbalance (>=80%)", details: `B:${bigCount}, S:${smallCount}` };

            // Check for very low prediction accuracy recently
            const recentPredictions = confirmedHistory.slice(0,10); // Already filtered for Win/Loss
            const recentCorrectPredictions = recentPredictions.filter(p => p.status === "Win").length;
            if (recentPredictions.length === 10 && recentCorrectPredictions <= 2) return { isStable: false, reason: alphaX_translations[alphaX_currentLanguage].unstable_trend_detected || "Very low recent prediction accuracy (<=20%)", details: `${recentCorrectPredictions}/10 correct` };
            
            // Check for long streak of the same actual outcome
            let currentActualStreak = 0; let lastActual = null;
            const actualBSSequence = confirmedHistory.slice(0,10).map(p => alphaX_getBigSmallFromActual(p.actual)).filter(r => r); // Get B/S from actuals
            if (actualBSSequence.length >=5) { // Only check if we have enough actual B/S outcomes
                for (const entry of actualBSSequence) {
                    if (entry === lastActual) currentActualStreak++; else { lastActual = entry; currentActualStreak = 1;}
                    if (currentActualStreak >= 5) return { isStable: false, reason: alphaX_translations[alphaX_currentLanguage].unstable_trend_detected || "Long streak of same actual outcome (>=5)", details: `${lastActual} streak of ${currentActualStreak}`};
                }
            }
            return { isStable: true, reason: "Trend appears stable enough for prediction.", details: "" };
        }
        
        function alphaX_getDynamicWeightAdjustment(signalSourceBase) {
            const performance = alphaX_signalPerformance[signalSourceBase];
            if (!performance || !Array.isArray(performance.history) || performance.history.length < 5) return 1.0; // Default weight if not enough data
            const recentAccuracy = performance.history.slice(-5).reduce((a,b) => a+b, 0) / 5; // Accuracy in last 5 uses
            if (recentAccuracy >= 0.8) return 1.30; // Boost good performers
            if (recentAccuracy >= 0.6) return 1.15;
            if (recentAccuracy <= 0.2) return 0.70; // Penalize poor performers
            if (recentAccuracy <= 0.4) return 0.85;
            return 1.0;
        }


        // --- Prediction Engine Core ---
        function alphaX_generateBigSmallPrediction(history) {
            // First, check if predictions are globally disabled by the timer system
            if (alphaX_isPredictionSystemDisabled) {
                alphaX_updatePredictionDisabledUI(); // Ensure popup is shown
                return { prediction: "SKIP", confidence: 0, skipReason: alphaX_predictionSystemDisableReason, source: "SystemDisabled" };
            }

            const stability = alphaX_analyzeTrendStability(history);
            if (!stability.isStable) {
                // If trend is unstable, disable predictions for a set duration
                alphaX_disablePredictionSystem(stability.reason, BAD_TREND_DISABLE_MINUTES);
                return { prediction: "SKIP", confidence: 0, skipReason: stability.reason, skipDetails: stability.details, source: "StabilityGuard" };
            }

            const confirmedHistory = history.filter(p => p && p.actual !== null && (p.status === "Win" || p.status === "Loss"));
            if (confirmedHistory.length < 5) return { prediction: Math.random() > 0.5 ? "BIG" : "SMALL", confidence: 38, source: "InsufficientDataDefault" };

            let signals = [];
            const getSignal = (fn, ...args) => {
                const baseSignalName = fn.name.replace('analyze', '').replace('AlphaX_', ''); // For performance tracking
                const result = fn(...args);
                // Apply dynamic weight adjustment based on past performance of this signal source
                if (result && result.weight) result.weight *= alphaX_getDynamicWeightAdjustment(baseSignalName);
                return result;
            };
            
            // Calling all analytical engines (existing and new conceptual ones)
            signals.push(getSignal(alphaX_analyzeFrequency, confirmedHistory, 5, 0.10));
            signals.push(getSignal(alphaX_analyzeFrequency, confirmedHistory, 10, 0.12));
            signals.push(getSignal(alphaX_analyzeFrequency, confirmedHistory, 15, 0.08));
            signals.push(getSignal(alphaX_analyzeTransitions, confirmedHistory, 0.15)); // Existing, can be part of Markov
            signals.push(getSignal(alphaX_analyzeStreaks, confirmedHistory, 0.13));
            signals.push(getSignal(alphaX_analyzeAlternatingPatterns, confirmedHistory, 0.10));
            signals.push(getSignal(alphaX_analyzeWeightedHistorical, confirmedHistory, 0.88, 0.11));
            signals.push(getSignal(alphaX_analyzeRSI, confirmedHistory, 14, 0.09));
            signals.push(getSignal(alphaX_analyzeMACD, confirmedHistory, 5, 10, 4, 0.07));
            signals.push(getSignal(alphaX_analyzeBollingerBands, confirmedHistory, 10, 2, 0.06));
            
            // Engines from user's list (some were already similar)
            signals.push(getSignal(alphaX_analyzeSumRange, confirmedHistory, 4, 0.05)); // Already: alphaX_analyzeSumRanges
            signals.push(getSignal(alphaX_analyzeHighLowRatio, confirmedHistory, 12, 0.05)); // Already exists
            signals.push(getSignal(alphaX_analyzeSumFrequencyTracker, confirmedHistory, 6, 0.07)); // Already: alphaX_analyzeSumFrequency
            signals.push(getSignal(alphaX_analyzeNumberDistribution, confirmedHistory, 12, 0.04)); // Already exists
            signals.push(getSignal(alphaX_analyzeConsecutiveNumber, confirmedHistory, 6, 0.03)); // Already: alphaX_analyzeConsecutiveNumbers
            signals.push(getSignal(alphaX_analyzeGapAnalysisEngine, confirmedHistory, 6, 0.04)); // Already: alphaX_analyzeGapAnalysis
            
            // Conceptual/Simplified Engines
            signals.push(getSignal(alphaX_analyzeDrawingMachineBias, confirmedHistory, 0.01));
            signals.push(getSignal(alphaX_analyzeMLEngine_conceptual, confirmedHistory, 0.03));
            signals.push(getSignal(alphaX_analyzeMonteCarlo_conceptual, confirmedHistory, 0.02));
            signals.push(getSignal(alphaX_analyzeMarkovChain_simplified, confirmedHistory, 0.05)); // Can enhance transitions
            signals.push(getSignal(alphaX_analyzeGA_conceptual, confirmedHistory, 0.01));
            signals.push(getSignal(alphaX_analyzeFractal_conceptual, confirmedHistory, 0.01));
            signals.push(getSignal(alphaX_analyzeChaosTheory_conceptual, confirmedHistory, 0.01));
            signals.push(getSignal(alphaX_analyzeWavelet_conceptual, confirmedHistory, 0.01));
            signals.push(getSignal(alphaX_analyzeInformationTheoryEntropy, confirmedHistory, 0.03));
            // ... add calls for other conceptual engines with small weights ...
            signals.push(getSignal(alphaX_analyzeGraphTheory_conceptual, confirmedHistory, 0.01));
            signals.push(getSignal(alphaX_analyzeBayesianInference_conceptual, confirmedHistory, 0.02));
            signals.push(getSignal(alphaX_analyzeCopulaModeling_conceptual, confirmedHistory, 0.01));
            signals.push(getSignal(alphaX_analyzeRL_conceptual, confirmedHistory, 0.01));
            signals.push(getSignal(alphaX_analyzeTDA_conceptual, confirmedHistory, 0.01));
            signals.push(getSignal(alphaX_analyzeRQA_conceptual, confirmedHistory, 0.01));
            signals.push(getSignal(alphaX_analyzeHMM_conceptual, confirmedHistory, 0.01));
            signals.push(getSignal(alphaX_analyzeOptimalTransport_conceptual, confirmedHistory, 0.01));


            signals = signals.filter(s => s !== null && s.prediction !== "SKIP" && typeof s.weight === 'number' && s.weight > 0.005); // Lowered threshold slightly for conceptual engines

            if (signals.length === 0) return { prediction: "SMALL", confidence: 33, source: "NoClearSignals_Fallback_V3.1" };

            // Inter-Signal Confirmation (Simplified)
            if (signals.length > 3) {
                let bigSignalCount = signals.filter(s => s.prediction === "BIG").length;
                let smallSignalCount = signals.filter(s => s.prediction === "SMALL").length;
                const totalSignalsForConfirm = bigSignalCount + smallSignalCount;
                if (totalSignalsForConfirm > 0) {
                    const agreementThreshold = 0.65; // Slightly lower threshold due to more diverse signals
                    if (bigSignalCount / totalSignalsForConfirm >= agreementThreshold) signals.push({prediction: "BIG", weight: 0.10, source: "InterSignalConfirmV2"});
                    else if (smallSignalCount / totalSignalsForConfirm >= agreementThreshold) signals.push({prediction: "SMALL", weight: 0.10, source: "InterSignalConfirmV2"});
                }
            }
            

            let bigScore = 0; let smallScore = 0; let totalWeight = 0;
            let contributingSources = new Set(); let topSignalSource = null; let maxSignalWeight = 0;

            signals.forEach(signal => {
                if (signal.prediction === "BIG") bigScore += signal.weight;
                else if (signal.prediction === "SMALL") smallScore += signal.weight;
                totalWeight += signal.weight;
                contributingSources.add(signal.source.split('-')[0]); // Group by base source for diversity count
                if(signal.weight > maxSignalWeight) { maxSignalWeight = signal.weight; topSignalSource = signal.source; }
            });

            let finalPrediction = (bigScore >= smallScore) ? "BIG" : "SMALL";
            let confidence = 25; // Base confidence
            if (totalWeight > 0) {
                const predominance = Math.abs(bigScore - smallScore) / totalWeight;
                confidence += predominance * 40; // Increased impact of predominance
                confidence += Math.min(contributingSources.size * 2.5, 25); // Diversity of sources
            }
            confidence += Math.min(signals.length * 1.0, 15); // Number of agreeing signals

            // Adjustments
            const agreeingSignalsRatio = signals.length > 0 ? signals.filter(s => s.prediction === finalPrediction).length / signals.length : 0;
            if (agreeingSignalsRatio > 0.75 && signals.length >= 4) confidence += 8;
            if (maxSignalWeight / totalWeight > 0.5 && signals.length > 2) confidence += 3; // If one signal is very dominant
            // Penalty if scores are very close despite many signals (uncertainty)
            if (signals.length > 5 && (bigScore / totalWeight > 0.45 && smallScore / totalWeight > 0.45)) confidence -= 6;


            if (!alphaX_isAdvancedModeActive && confidence > 65) confidence = 65 + (confidence - 65) * 0.25; // Cap normal mode slightly more
            confidence = Math.min(Math.max(Math.floor(confidence), 20), 97); // Final clamping

            return { prediction: finalPrediction, confidence: confidence, source: topSignalSource || signals[0]?.source || "EnsembleV3" };
        }

        // --- Helper & Analytical Functions (Existing and New Conceptual Stubs) ---
        function alphaX_calculateSMA(data, period) { if (data.length < period) return null; const sum = data.slice(0, period).reduce((a, b) => a + b, 0); return sum / period; }
        function alphaX_calculateEMA(data, period) { if (data.length < period) return null; const k = 2 / (period + 1); let ema = alphaX_calculateSMA(data.slice(data.length - period * 2, data.length - period), period); if (ema === null && data.length >= period) ema = data[data.length - period]; else if (ema === null) return null; for (let i = data.length - period; i < data.length; i++) { ema = (data[i] * k) + (ema * (1 - k)); } return ema; }
        function alphaX_analyzeFrequency(history, windowSize = 10, weight = 0.15) { if (history.length < windowSize) return null; const recent = history.slice(0, windowSize).map(p => alphaX_getBigSmallFromActual(p.actual)).filter(bs => bs); if (recent.length < windowSize / 2) return null; const bigCount = recent.filter(bs => bs === "BIG").length; const smallCount = recent.filter(bs => bs === "SMALL").length; if (bigCount > smallCount) return { prediction: "BIG", weight: weight * (bigCount / recent.length), source: `Freq-${windowSize}W` }; if (smallCount > bigCount) return { prediction: "SMALL", weight: weight * (smallCount / recent.length), source: `Freq-${windowSize}W` }; return null;}
        function alphaX_analyzeTransitions(history, weight = 0.2) { if (history.length < 5) return null; const transitions = { "B": { "B": 0, "S": 0 }, "S": { "B": 0, "S": 0 } }; for (let i = 0; i < history.length - 1; i++) { const currentBS = alphaX_getBigSmallFromActual(history[i]?.actual); const prevBS = alphaX_getBigSmallFromActual(history[i+1]?.actual); if (currentBS && prevBS) { if (!transitions[prevBS]) transitions[prevBS] = { "B": 0, "S": 0 }; transitions[prevBS][currentBS]++; } } const lastOutcome = alphaX_getBigSmallFromActual(history[0]?.actual); if (!lastOutcome || !transitions[lastOutcome] || (transitions[lastOutcome]["B"] + transitions[lastOutcome]["S"] === 0)) return null; const nextBigProb = transitions[lastOutcome]["B"] / (transitions[lastOutcome]["B"] + transitions[lastOutcome]["S"] || 1); const nextSmallProb = transitions[lastOutcome]["S"] / (transitions[lastOutcome]["B"] + transitions[lastOutcome]["S"] || 1); if (nextBigProb > nextSmallProb + 0.1) return { prediction: "BIG", weight: weight * nextBigProb, source: "Transition" }; if (nextSmallProb > nextBigProb + 0.1) return { prediction: "SMALL", weight: weight * nextSmallProb, source: "Transition" }; return null; }
        function alphaX_analyzeStreaks(history, weight = 0.18) {  if (history.length < 3) return null; const actuals = history.map(p => alphaX_getBigSmallFromActual(p.actual)).filter(bs => bs); if (actuals.length < 3) return null; let currentStreakType = actuals[0]; let currentStreakLength = 0; for (const outcome of actuals) { if (outcome === currentStreakType) currentStreakLength++; else break; } let prediction; let calculatedWeight = weight; if (currentStreakLength >= 3) { prediction = currentStreakType === "BIG" ? "SMALL" : "BIG"; if (currentStreakLength >= 5) { calculatedWeight *= 0.7; } else { calculatedWeight *= (currentStreakLength / 4); } return { prediction: prediction, weight: Math.min(calculatedWeight, weight), source: `StreakBreak-${currentStreakLength}` }; } if (actuals.length >=2 && actuals[0] !== actuals[1]) { return { prediction: actuals[0], weight: weight * 0.6, source: "StreakContinuation-New" }; } return null; }
        function alphaX_analyzeAlternatingPatterns(history, weight = 0.12) { if (history.length < 5) return null; const actuals = history.slice(0, 5).map(p => alphaX_getBigSmallFromActual(p.actual)).filter(bs => bs); if (actuals.length < 4) return null; if (actuals[0] === "SMALL" && actuals[1] === "BIG" && actuals[2] === "SMALL" && actuals[3] === "BIG") { return { prediction: "SMALL", weight: weight, source: "Alt-BSBS" }; } if (actuals[0] === "BIG" && actuals[1] === "SMALL" && actuals[2] === "BIG" && actuals[3] === "SMALL") { return { prediction: "BIG", weight: weight, source: "Alt-SBSB" }; } return null; }
        function alphaX_analyzeWeightedHistorical(history, weightDecayFactor = 0.88, baseWeight = 0.11) { if (history.length < 5) return null; let bigWeightedScore = 0; let smallWeightedScore = 0; let currentWeight = 1.0; const maxHistory = Math.min(history.length, 15); for (let i = 0; i < maxHistory; i++) { const outcome = alphaX_getBigSmallFromActual(history[i].actual); if (outcome === "BIG") bigWeightedScore += currentWeight; else if (outcome === "SMALL") smallWeightedScore += currentWeight; currentWeight *= weightDecayFactor; } if (bigWeightedScore === 0 && smallWeightedScore === 0) return null; if (bigWeightedScore > smallWeightedScore) return { prediction: "BIG", weight: baseWeight * (bigWeightedScore / (bigWeightedScore + smallWeightedScore)), source: "WeightedHist" }; if (smallWeightedScore > bigWeightedScore) return { prediction: "SMALL", weight: baseWeight * (smallWeightedScore / (bigWeightedScore + smallWeightedScore)), source: "WeightedHist" }; return null; }
        function alphaX_calculateRSI(data, period) { if (!data || data.length < period + 1) { return null; } let gains = []; let losses = []; for (let i = 1; i < data.length; i++) { const change = data[i] - data[i - 1]; if (change > 0) { gains.push(change); losses.push(0); } else { gains.push(0); losses.push(Math.abs(change)); } } if (gains.length < period) { return null; } let avgGain = gains.slice(0, period).reduce((sum, val) => sum + val, 0) / period; let avgLoss = losses.slice(0, period).reduce((sum, val) => sum + val, 0) / period; for (let i = period; i < gains.length; i++) { avgGain = (avgGain * (period - 1) + gains[i]) / period; avgLoss = (avgLoss * (period - 1) + losses[i]) / period; } if (avgLoss === 0) { return 100; } const rs = avgGain / avgLoss; const rsi = 100 - (100 / (1 + rs)); return rsi; }
        function alphaX_analyzeRSI(history, rsiPeriod = 14, weight = 0.09) { const actualNumbers = history.map(entry => parseInt(entry.actual)).filter(num => !isNaN(num)).reverse(); if (actualNumbers.length < rsiPeriod + 1) { return null; } const rsiValue = alphaX_calculateRSI(actualNumbers, rsiPeriod); if (rsiValue === null) { return null; } let prediction = null; let signalWeight = 0; if (rsiValue < 28) { prediction = "BIG"; signalWeight = weight * ( (30 - rsiValue) / 30 + 1.1); } else if (rsiValue > 72) { prediction = "SMALL"; signalWeight = weight * ( (rsiValue - 70) / 30 + 1.1); } signalWeight = Math.min(signalWeight, weight * 1.6); if (prediction) { return { prediction: prediction, weight: signalWeight, source: "RSI" }; } return null; }
        function alphaX_analyzeSumRange(history, lookbackPeriod = 4, weight = 0.05) { const actualNumbers = history.map(entry => parseInt(entry.actual)).filter(num => !isNaN(num)); if (actualNumbers.length < lookbackPeriod) return null; const recentNumbers = actualNumbers.slice(0, lookbackPeriod); const sum = recentNumbers.reduce((acc, val) => acc + val, 0); const maxSum = lookbackPeriod * 9; const lowThreshold = maxSum * 0.30; const highThreshold = maxSum * 0.70; let prediction = null; if (sum < lowThreshold) { prediction = "SMALL"; } else if (sum > highThreshold) { prediction = "BIG"; } if (prediction) { return { prediction: prediction, weight: weight, source: "SumRange" }; } return null; }
        function alphaX_analyzeHighLowRatio(history, lookbackPeriod = 12, weight = 0.05) { const actualNumbers = history.map(entry => parseInt(entry.actual)).filter(num => !isNaN(num)); if (actualNumbers.length < lookbackPeriod) return null; const recentNumbers = actualNumbers.slice(0, lookbackPeriod); let highCount = 0; let lowCount = 0; recentNumbers.forEach(num => { if (num >= 5) highCount++; else lowCount++; }); if (highCount === 0 && lowCount === 0) return null; let prediction = null; if (highCount > lowCount * 1.6) { prediction = "BIG"; } else if (lowCount > highCount * 1.6) { prediction = "SMALL"; } if (prediction) { const ratioStrength = Math.abs(highCount - lowCount) / (highCount + lowCount); return { prediction: prediction, weight: weight * (1 + ratioStrength * 0.5), source: "HighLowRatio" }; } return null; }
        function alphaX_analyzeSumFrequencyTracker(history, pairLookback = 6, weight = 0.07) { const actualNumbers = history.map(entry => parseInt(entry.actual)).filter(num => !isNaN(num)); if (actualNumbers.length < pairLookback + 1) return null; const recentSums = []; for (let i = 0; i < pairLookback; i++) { if (actualNumbers[i] !== null && actualNumbers[i+1] !== null) { recentSums.push(actualNumbers[i] + actualNumbers[i+1]); } } if (recentSums.length === 0) return null; const averageSum = recentSums.reduce((acc, val) => acc + val, 0) / recentSums.length; let prediction = null; if (averageSum < 7.0) { prediction = "SMALL"; } else if (averageSum > 11.0) { prediction = "BIG"; } if (prediction) { const deviation = Math.abs(averageSum - 9) / 9; return { prediction: prediction, weight: weight * (1 + deviation * 0.8), source: "SumFreqTrack" }; } return null; }
        function alphaX_analyzeNumberDistribution(history, lookbackPeriod = 12, weight = 0.04) { const actualNumbers = history.map(entry => parseInt(entry.actual)).filter(num => !isNaN(num)); if (actualNumbers.length < lookbackPeriod) return null; const recentNumbers = actualNumbers.slice(0, lookbackPeriod); const segments = { "0-1": 0, "2-3": 0, "4-5": 0, "6-7": 0, "8-9": 0 }; recentNumbers.forEach(num => { if (num <= 1) segments["0-1"]++; else if (num <= 3) segments["2-3"]++; else if (num <= 5) segments["4-5"]++; else if (num <= 7) segments["6-7"]++; else segments["8-9"]++; }); const smallHeavy = segments["0-1"] + segments["2-3"]; const bigHeavy = segments["6-7"] + segments["8-9"]; let prediction = null; if (smallHeavy > bigHeavy * 1.4) prediction = "SMALL"; else if (bigHeavy > smallHeavy * 1.4) prediction = "BIG"; if(prediction) { return { prediction, weight, source: "NumDist" }; } return null; }
        function alphaX_analyzeConsecutiveNumber(history, lookbackPeriod = 6, weight = 0.03) { const actualNumbers = history.map(entry => parseInt(entry.actual)).filter(num => !isNaN(num)); if (actualNumbers.length < lookbackPeriod) return null; const recentSequence = actualNumbers.slice(0, lookbackPeriod); let consecutivePairs = 0; for(let i = 0; i < recentSequence.length - 1; i++) { if (Math.abs(recentSequence[i] - recentSequence[i+1]) === 1) { consecutivePairs++; } } if (consecutivePairs >= lookbackPeriod / 2 -1) { const lastOutcomeBS = alphaX_getBigSmallFromActual(actualNumbers[0]); if (lastOutcomeBS) { return { prediction: lastOutcomeBS, weight: weight * 0.6, source: "ConsecutiveNum" }; } } return null; }
        function alphaX_analyzeGapAnalysisEngine(history, lookbackPeriod = 6, weight = 0.04) { const actualNumbers = history.map(entry => parseInt(entry.actual)).filter(num => !isNaN(num)); if (actualNumbers.length < lookbackPeriod + 1) return null; const gaps = []; for (let i = 0; i < lookbackPeriod; i++) { gaps.push(Math.abs(actualNumbers[i] - actualNumbers[i+1])); } if (gaps.length === 0) return null; const averageGap = gaps.reduce((a,b) => a+b, 0) / gaps.length; const lastOutcomeBS = alphaX_getBigSmallFromActual(actualNumbers[0]); if (!lastOutcomeBS) return null; let prediction = null; if (averageGap < 1.8) { prediction = lastOutcomeBS; } else if (averageGap > 4.2) { prediction = lastOutcomeBS === "BIG" ? "SMALL" : "BIG"; } if (prediction) { return { prediction, weight, source: "GapAnalysisEng" }; } return null; }
        function alphaX_analyzeMACD(history, shortPeriod = 5, longPeriod = 10, signalPeriod = 4, weight = 0.07) { const actualNumbers = history.map(entry => parseInt(entry.actual)).filter(num => !isNaN(num)).reverse(); if (actualNumbers.length < longPeriod + signalPeriod) return null; const emaShort = alphaX_calculateEMA(actualNumbers, shortPeriod); const emaLong = alphaX_calculateEMA(actualNumbers, longPeriod); if (emaShort === null || emaLong === null) return null; const macdLine = emaShort - emaLong; const macdHistory = []; for(let i = longPeriod -1; i < actualNumbers.length; i++) { const short = alphaX_calculateEMA(actualNumbers.slice(0, i + 1), shortPeriod); const long = alphaX_calculateEMA(actualNumbers.slice(0, i + 1), longPeriod); if (short !== null && long !== null) macdHistory.push(short - long); } if (macdHistory.length < signalPeriod) return null; const signalLine = alphaX_calculateEMA(macdHistory, signalPeriod); if (signalLine === null) return null; let prediction = null; if (macdLine > signalLine * 1.08) prediction = "BIG"; else if (macdLine < signalLine * 0.92) prediction = "SMALL"; if (prediction) { return { prediction, weight, source: "MACD" }; } return null; }
        function alphaX_analyzeBollingerBands(history, period = 10, stdDevMultiplier = 2, weight = 0.06) { const actualNumbers = history.map(entry => parseInt(entry.actual)).filter(num => !isNaN(num)); if (actualNumbers.length < period) return null; const recentSlice = actualNumbers.slice(0, period).reverse(); const sma = alphaX_calculateSMA(recentSlice, period); if (sma === null) return null; const variance = recentSlice.reduce((acc, val) => acc + Math.pow(val - sma, 2), 0) / period; const stdDev = Math.sqrt(variance); const upperBand = sma + (stdDev * stdDevMultiplier); const lowerBand = sma - (stdDev * stdDevMultiplier); const lastNumber = actualNumbers[0]; let prediction = null; if (lastNumber > upperBand * 1.02) prediction = "SMALL"; else if (lastNumber < lowerBand * 0.98) prediction = "BIG"; if (prediction) { return { prediction, weight, source: "Bollinger" }; } return null; }
        
        // Conceptual/Simplified Engines (Stubs with minimal logic)
        function alphaX_analyzeDrawingMachineBias(history, weight = 0.01) { /* Highly speculative, returns random small influence */ if (Math.random() < 0.1) return { prediction: Math.random() > 0.5 ? "BIG" : "SMALL", weight: weight, source: "MachineBiasConc" }; return null; }
        function alphaX_analyzeMLEngine_conceptual(history, weight = 0.03) { /* Placeholder */ const lastOutcome = alphaX_getBigSmallFromActual(history[0]?.actual); if (lastOutcome && Math.random() < 0.2) return { prediction: lastOutcome, weight: weight, source: "MLConc" }; return null; }
        function alphaX_analyzeMonteCarlo_conceptual(history, weight = 0.02) { /* Placeholder */ if (Math.random() < 0.15) return { prediction: Math.random() > 0.5 ? "BIG" : "SMALL", weight: weight, source: "MonteCarloConc" }; return null; }
        function alphaX_analyzeMarkovChain_simplified(history, weight = 0.05) { /* Simplified - can be similar to transitions or more states */ return alphaX_analyzeTransitions(history, weight); } // Re-use transitions or expand
        function alphaX_analyzeGA_conceptual(history, weight = 0.01) { /* Placeholder */ return null; }
        function alphaX_analyzeFractal_conceptual(history, weight = 0.01) { /* Placeholder */ return null; }
        function alphaX_analyzeChaosTheory_conceptual(history, weight = 0.01) { /* Placeholder */ return null; }
        function alphaX_analyzeWavelet_conceptual(history, weight = 0.01) { /* Placeholder */ return null; }
        function alphaX_analyzeInformationTheoryEntropy(history, weight = 0.03) {
            const outcomes = history.slice(0, 20).map(p => alphaX_getBigSmallFromActual(p.actual)).filter(bs => bs);
            if (outcomes.length < 10) return null;
            const counts = outcomes.reduce((acc, val) => { acc[val] = (acc[val] || 0) + 1; return acc; }, {});
            let entropy = 0;
            for (const key in counts) {
                const p = counts[key] / outcomes.length;
                entropy -= p * Math.log2(p);
            }
            // Lower entropy might suggest predictability (less random)
            if (entropy < 1.2 && outcomes.length >=10) { // Arbitrary threshold for "less random"
                 const lastOutcome = outcomes[0];
                 if(lastOutcome) return { prediction: lastOutcome, weight: weight * ( (1.5 - entropy)/1.5 + 0.5) , source: "Entropy" }; // Predict continuation if less random
            }
            return null;
        }
        function alphaX_analyzeGraphTheory_conceptual(history, weight = 0.01) { /* Placeholder */ return null; }
        function alphaX_analyzeBayesianInference_conceptual(history, weight = 0.02) { /* Placeholder */ return null; }
        function alphaX_analyzeCopulaModeling_conceptual(history, weight = 0.01) { /* Placeholder */ return null; }
        function alphaX_analyzeRL_conceptual(history, weight = 0.01) { /* Placeholder */ return null; }
        function alphaX_analyzeTDA_conceptual(history, weight = 0.01) { /* Placeholder */ return null; }
        function alphaX_analyzeRQA_conceptual(history, weight = 0.01) { /* Placeholder */ return null; }
        function alphaX_analyzeHMM_conceptual(history, weight = 0.01) { /* Placeholder */ return null; }
        function alphaX_analyzeOptimalTransport_conceptual(history, weight = 0.01) { /* Placeholder */ return null; }


        async function alphaX_fetchGameResultsFromAPI() {
            try {
                const requestPayload = { pageSize: 10, pageNo: 1, typeId: 1, language: 0, random: "4a0522c6ecd8410496260e686be2a57c", signature: "334B5E70A0C9B8918B0B15E517E2069C", timestamp: Math.floor(Date.now() / 1000) };
                const response = await fetch("https://api.bdg88zf.com/api/webapi/GetNoaverageEmerdList", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(requestPayload) });
                if (!response.ok) { const errorData = await response.text(); console.error("API request failed:", response.status, response.statusText, errorData); let userMessage = `${alphaX_translations[alphaX_currentLanguage].api_error || 'API Error'} (Status: ${response.status})`; if (errorData.toLowerCase().includes("wrong signature") || (response.status === 500 && errorData.toLowerCase().includes("wrong signature"))) { userMessage = `API Error: Wrong Signature. (Code: ${response.status})`; console.error("API Signature Error: The static 'random' and 'signature' values might be incorrect or expired."); } else if (response.status === 401 || response.status === 403) { userMessage = `API Auth Error (Code: ${response.status}). Check credentials.`; console.error("API Authentication Error."); } alphaX_updateServerStatusUI(false, userMessage); return []; }
                const data = await response.json();
                if (data && data.code === 5) { console.error("API returned 'Wrong signature' (Code: 5)."); alphaX_updateServerStatusUI(false, `API Error: Wrong Signature (Code: ${data.code}).`); return []; }
                if (data && data.code !== 0 && data.msg) { console.error("API returned an error:", data.msg, "Code:", data.code); alphaX_updateServerStatusUI(false, `${alphaX_translations[alphaX_currentLanguage].api_error || 'API Error'} - ${data.msg}`); return []; }
                if (data && data.data && data.data.list) { alphaX_updateServerStatusUI(true); return data.data.list; }
                else { console.error("Unexpected API response structure:", data); alphaX_updateServerStatusUI(false, alphaX_translations[alphaX_currentLanguage].api_error || 'API Error'); return []; }
            } catch (error) { console.error("Fetch error:", error); alphaX_updateServerStatusUI(false, alphaX_translations[alphaX_currentLanguage].api_error || 'API Error'); return []; }
        }
        
        function alphaX_updateSignalPerformance(predicted, actual, sourceBase) {
            if (!sourceBase || !predicted || !actual) return;
            if (!alphaX_signalPerformance[sourceBase]) alphaX_signalPerformance[sourceBase] = { history: [], correct: 0, total: 0 };
            const perf = alphaX_signalPerformance[sourceBase];
            perf.total++;
            if (predicted === actual) { perf.correct++; perf.history.push(1); } else { perf.history.push(0); }
            if (perf.history.length > 20) perf.history.shift(); // Keep last 20 results for this signal
            localStorage.setItem('alphaXAiSignalPerformance_v2', JSON.stringify(alphaX_signalPerformance));
        }


        function alphaX_updateStatsAndHistory(latestApiResultNumber, periodToUpdate) {
            const entryToUpdate = alphaX_appHistory.find(p => p.periodFull === periodToUpdate && p.status === "Pending");
            if (entryToUpdate) {
                const actualNumber = parseInt(latestApiResultNumber); entryToUpdate.actual = actualNumber;
                const actualBigOrSmall = alphaX_getBigSmallFromActual(actualNumber); const predictedBigOrSmall = entryToUpdate.prediction;
                if (actualBigOrSmall && predictedBigOrSmall === actualBigOrSmall) { entryToUpdate.status = "Win"; alphaX_currentStreak = alphaX_currentStreak >= 0 ? alphaX_currentStreak + 1 : 1; alphaX_playSound('win'); }
                else if (actualBigOrSmall && predictedBigOrSmall !== "SKIP") { entryToUpdate.status = "Loss"; alphaX_currentStreak = alphaX_currentStreak <= 0 ? alphaX_currentStreak - 1 : -1; alphaX_playSound('loss'); }
                else { entryToUpdate.status = "Skipped"; alphaX_playSound('skipped'); } // If prediction was SKIP or actual was invalid
                localStorage.setItem('alphaXCurrentStreak', alphaX_currentStreak.toString());
                // Update signal performance
                if (entryToUpdate.predictionSource && actualBigOrSmall) {
                     alphaX_updateSignalPerformance(predictedBigOrSmall, actualBigOrSmall, entryToUpdate.predictionSource.split('-')[0]);
                }
            }
            localStorage.setItem('alphaXAiHistory_v2', JSON.stringify(alphaX_appHistory));
        }

        async function alphaX_fetchPredictionData() {
            if (alphaX_isMaintenanceModeActive) {
                console.log("Maintenance mode active. Halting prediction fetch.");
                if(alphaX_currentResultEl) alphaX_currentResultEl.textContent = alphaX_translations[alphaX_currentLanguage]?.under_maintenance || "Under Maintenance";
                if(alphaX_serverStatusEl) alphaX_serverStatusEl.textContent = alphaX_translations[alphaX_currentLanguage]?.under_maintenance || "Under Maintenance";
                if(alphaX_serverStatusIndicator) alphaX_serverStatusIndicator.className = 'w-3 h-3 bg-warning-color rounded-full';
                return;
            }
            
            // Check if system is disabled and try to resume if time is up
            if (alphaX_isPredictionSystemDisabled) {
                if (alphaX_checkAndResumePredictionSystem()) {
                    // System resumed, proceed to fetch data
                } else {
                    alphaX_updatePredictionDisabledUI(); // Still disabled, ensure UI reflects this
                    return; // Don't fetch data if still disabled
                }
            }

            if(alphaX_currentResultEl) alphaX_currentResultEl.textContent = alphaX_translations[alphaX_currentLanguage].fetching_data || "Fetching...";

            const apiResults = await alphaX_fetchGameResultsFromAPI();
            if (!apiResults || apiResults.length === 0) {
                if (alphaX_currentResultEl && (!alphaX_currentResultEl.textContent || alphaX_currentResultEl.textContent === "-" || alphaX_currentResultEl.textContent === (alphaX_translations[alphaX_currentLanguage].fetching_data || "Fetching..."))) {
                     if (alphaX_serverStatusEl && alphaX_serverStatusEl.textContent.toLowerCase().includes("error")) alphaX_currentResultEl.textContent = alphaX_serverStatusEl.textContent;
                     else alphaX_currentResultEl.textContent = alphaX_translations[alphaX_currentLanguage].api_error || "API Error";
                }
                return;
            }

            const latestApiEntry = apiResults[0]; const latestApiPeriodFull = latestApiEntry.issueNumber; const latestApiResultNumber = latestApiEntry.number;
            alphaX_updateStatsAndHistory(latestApiResultNumber, latestApiPeriodFull); // Update history with latest actual result
            
            const nextPeriodToPredictFull = (BigInt(latestApiPeriodFull) + 1n).toString(); const nextPeriodToPredictDisplay = nextPeriodToPredictFull.slice(-5);
            const existingPendingForNext = alphaX_appHistory.find(p => p.periodFull === nextPeriodToPredictFull && p.status === "Pending");

            if (!existingPendingForNext || existingPendingForNext.periodFull !== alphaX_lastFetchedPeriod) {
                const predictionResult = alphaX_generateBigSmallPrediction(alphaX_appHistory); // Generate new prediction
                
                // If prediction system got disabled during generateBigSmallPrediction (e.g. by stability check)
                if (alphaX_isPredictionSystemDisabled) {
                    alphaX_updatePredictionDisabledUI();
                    return; 
                }

                const newPredictionEntry = { periodFull: nextPeriodToPredictFull, periodDisplay: nextPeriodToPredictDisplay, prediction: predictionResult.prediction, confidence: predictionResult.confidence, status: predictionResult.prediction === "SKIP" ? "Skipped" : "Pending", actual: null, timestamp: Date.now(), skipReason: predictionResult.skipReason, skipDetails: predictionResult.skipDetails, predictionSource: predictionResult.source };

                if (predictionResult.prediction === "SKIP") {
                    // This case should ideally be handled by alphaX_disablePredictionSystem if it's a stability issue
                    if(alphaX_currentPeriodEl) alphaX_currentPeriodEl.textContent = nextPeriodToPredictDisplay;
                    if(alphaX_currentResultEl) alphaX_currentResultEl.textContent = alphaX_translations[alphaX_currentLanguage].predictions_disabled || "Predictions Disabled";
                    if(alphaX_confidenceFillEl) alphaX_confidenceFillEl.style.width = "0%"; if(alphaX_confidenceTextEl) alphaX_confidenceTextEl.textContent = "0%";
                    // If skipReason is present, it might be from a non-disabling SKIP. Show banner if appropriate.
                    if (predictionResult.skipReason) alphaX_showBadTrendIndicatorUI(predictionResult.skipReason, predictionResult.skipDetails);

                } else { // Normal prediction
                    alphaX_hideBadTrendIndicatorUI(); // Hide if it was previously shown for a non-disabling SKIP
                    if(alphaX_currentPeriodEl) alphaX_currentPeriodEl.textContent = nextPeriodToPredictDisplay;
                    if(alphaX_currentResultEl) alphaX_currentResultEl.textContent = predictionResult.prediction;
                    if(alphaX_confidenceFillEl) alphaX_confidenceFillEl.style.width = `${predictionResult.confidence}%`;
                    if(alphaX_confidenceTextEl) alphaX_confidenceTextEl.textContent = `${predictionResult.confidence}%`;
                    if (alphaX_isNotificationsEnabled && Notification.permission === 'granted') { new Notification(`ALPHA X AI: ${predictionResult.prediction}`, { body: `Period: ${nextPeriodToPredictDisplay} | Confidence: ${predictionResult.confidence}%`, icon: 'https://placehold.co/64x64/38B2AC/FFFFFF?text=AX' }); alphaX_playSound('notify'); }
                }
                alphaX_appHistory.unshift(newPredictionEntry); alphaX_appHistory = alphaX_appHistory.slice(0, 100); // Keep history to 100 entries
                localStorage.setItem('alphaXAiHistory_v2', JSON.stringify(alphaX_appHistory));
                alphaX_lastFetchedPeriod = nextPeriodToPredictFull;
            } else if (existingPendingForNext) { // Display existing pending prediction for the current period
                 if(alphaX_currentPeriodEl) alphaX_currentPeriodEl.textContent = existingPendingForNext.periodDisplay;
                 if(alphaX_currentResultEl) alphaX_currentResultEl.textContent = existingPendingForNext.prediction;
                 if(alphaX_confidenceFillEl) alphaX_confidenceFillEl.style.width = `${existingPendingForNext.confidence}%`;
                 if(alphaX_confidenceTextEl) alphaX_confidenceTextEl.textContent = `${existingPendingForNext.confidence}%`;
                 if(existingPendingForNext.prediction === "SKIP" && existingPendingForNext.skipReason) alphaX_showBadTrendIndicatorUI(existingPendingForNext.skipReason, existingPendingForNext.skipDetails);
                 else alphaX_hideBadTrendIndicatorUI();
            }
            alphaX_updateDashboardAndStats(); alphaX_updateHistoryUI(); alphaX_checkWinStreakAndNotify();
        }
        function alphaX_updateDashboardAndStats() {
            const confirmedHistory = alphaX_appHistory.filter(p => p && (p.status === "Win" || p.status === "Loss"));
            const wins = confirmedHistory.filter(p => p.status === "Win").length; const losses = confirmedHistory.filter(p => p.status === "Loss").length;
            const winRate = (wins + losses) > 0 ? Math.round((wins / (wins + losses)) * 100) : 0;
            if(alphaX_winRateEl) alphaX_winRateEl.textContent = `${winRate}%`; if(alphaX_totalWinBetsEl) alphaX_totalWinBetsEl.textContent = wins; if(alphaX_totalLossBetsEl) alphaX_totalLossBetsEl.textContent = losses;
            if(alphaX_statsTotalWinsEl) alphaX_statsTotalWinsEl.textContent = wins; if(alphaX_statsTotalLossesEl) alphaX_statsTotalLossesEl.textContent = losses; if(alphaX_statsWinRateEl) alphaX_statsWinRateEl.textContent = `${winRate}%`;
            if(alphaX_currentStreakEl) {
                if (alphaX_currentStreak > 0) { alphaX_currentStreakEl.textContent = `W${alphaX_currentStreak}`; alphaX_currentStreakEl.className = 'text-xl font-bold text-win-color'; }
                else if (alphaX_currentStreak < 0) { alphaX_currentStreakEl.textContent = `L${Math.abs(alphaX_currentStreak)}`; alphaX_currentStreakEl.className = 'text-xl font-bold text-loss-color'; }
                else { alphaX_currentStreakEl.textContent = '-'; alphaX_currentStreakEl.className = 'text-xl font-bold text-text-light-primary'; }
            }
            const lastFiveActuals = alphaX_appHistory.filter(p => p && p.actual !== null).slice(0, 5).map(p => p.actual).join(', ') || '-';
            if(alphaX_lastFiveActualsEl) alphaX_lastFiveActualsEl.textContent = lastFiveActuals;
            const bigSmallCounts = { BIG: 0, SMALL: 0 };
            confirmedHistory.forEach(entry => { if(entry.actual !== null){ const bs = alphaX_getBigSmallFromActual(parseInt(entry.actual)); if (bs === "BIG") bigSmallCounts.BIG++; else if (bs === "SMALL") bigSmallCounts.SMALL++; } });
            if(alphaX_mostFrequentBigSmallEl && alphaX_leastFrequentBigSmallEl) {
                if (bigSmallCounts.BIG === 0 && bigSmallCounts.SMALL === 0) { alphaX_mostFrequentBigSmallEl.textContent = '-'; alphaX_leastFrequentBigSmallEl.textContent = '-'; }
                else if (bigSmallCounts.BIG >= bigSmallCounts.SMALL) { alphaX_mostFrequentBigSmallEl.textContent = 'BIG'; alphaX_leastFrequentBigSmallEl.textContent = bigSmallCounts.SMALL > 0 || bigSmallCounts.BIG === 0 ? 'SMALL' : (bigSmallCounts.BIG > 0 ? 'BIG' : '-'); }
                else { alphaX_mostFrequentBigSmallEl.textContent = 'SMALL'; alphaX_leastFrequentBigSmallEl.textContent = bigSmallCounts.BIG > 0 || bigSmallCounts.SMALL === 0 ? 'BIG' : (bigSmallCounts.SMALL > 0 ? 'SMALL' : '-'); }
            }
        }

        function alphaX_updateHistoryUI() {
            if(!alphaX_historyContainer) return; alphaX_historyContainer.innerHTML = '';
            if (alphaX_appHistory.length === 0) { alphaX_historyContainer.innerHTML = `<p class="text-center text-text-light-secondary p-4" data-lang-key="no_history">${alphaX_translations[alphaX_currentLanguage]?.no_history || "No history yet."}</p>`; return; }
            alphaX_appHistory.forEach((entry, index) => {
                if(!entry) return; const status = (entry.status || 'pending').toLowerCase();
                const iconClass = { win: 'fas fa-check-circle', loss: 'fas fa-times-circle', pending: 'fas fa-hourglass-half', skipped: 'fas fa-ban' }[status] || 'fas fa-question-circle';
                const badgeClass = { win: 'win-icon', loss: 'loss-icon', pending: 'pending-icon', skipped: 'skipped-icon' }[status] || '';
                const historyItem = document.createElement('div'); historyItem.className = `history-item ${status} flex items-center justify-between p-4 rounded-xl animate__animated animate__fadeInUp animate__faster`; historyItem.style.animationDelay = `${index * 0.05}s`;
                let skipDetailsHTML = ''; if (status === 'skipped' && entry.skipReason) skipDetailsHTML = `<div class="text-xs mt-1 italic text-text-light-secondary">${entry.skipReason}${entry.skipDetails ? `: ${entry.skipDetails}` : ''}</div>`;
                historyItem.innerHTML = ` <div class="watermark">ALPHA X AI</div> <div class="flex items-center space-x-3 flex-grow"> <div class="status-icon ${badgeClass}"> <i class="${iconClass}"></i></div> <div class="flex-grow"> <p class="text-lg font-semibold text-text-light-primary">${entry.periodDisplay || (entry.periodFull ? entry.periodFull.slice(-5) : 'N/A')}</p> <div class="flex flex-wrap text-sm gap-x-3 text-text-light-secondary"> ${entry.prediction ? `<span>${alphaX_translations[alphaX_currentLanguage]?.prediction || 'Prediction'}: <strong class="text-text-light-primary">${entry.prediction || '-'}</strong></span>` : ''} ${entry.actual !== null ? `<span>Actual: <strong class="text-text-light-primary">${entry.actual} (${alphaX_getBigSmallFromActual(entry.actual) || 'N/A'})</strong></span>` : ''} ${entry.confidence ? `<span>${alphaX_translations[alphaX_currentLanguage]?.confidence || 'Confidence'}: <strong class="text-text-light-primary">${entry.confidence}%</strong></span>` : ''} </div> <p class="text-sm capitalize font-medium mt-1 text-text-light-primary">${alphaX_translations[alphaX_currentLanguage]?.[status] || status}</p> ${skipDetailsHTML} </div> </div> <button class="delete-btn text-text-light-secondary hover:text-accent-primary transition ml-2 p-2 rounded-full" data-index="${index}" title="Delete this item"> <i class="fas fa-trash-alt text-lg"></i></button> `;
                alphaX_historyContainer.appendChild(historyItem);
                historyItem.querySelector('.delete-btn').addEventListener('click', (e) => { e.stopPropagation(); alphaX_showConfirmModal('delete_item_confirm', () => { alphaX_appHistory.splice(index, 1); localStorage.setItem('alphaXAiHistory_v2', JSON.stringify(alphaX_appHistory)); alphaX_updateHistoryUI(); alphaX_updateDashboardAndStats(); alphaX_playSound('confirm'); }); });
            });
        }

        function alphaX_updateServerStatusUI(isConnected, message = null) {
            const lang = alphaX_currentLanguage;
            if(alphaX_serverStatusEl && alphaX_serverStatusIndicator) {
                if (alphaX_isMaintenanceModeActive) {
                    alphaX_serverStatusEl.textContent = message || alphaX_translations[lang]?.under_maintenance || alphaX_translations['en']?.under_maintenance;
                    alphaX_serverStatusIndicator.className = 'w-3 h-3 bg-warning-color rounded-full'; // Yellow for maintenance
                } else if (isConnected) {
                    alphaX_serverStatusEl.textContent = message || alphaX_translations[lang]?.connected || alphaX_translations['en']?.connected;
                    alphaX_serverStatusIndicator.className = 'w-3 h-3 bg-win-color rounded-full animate-ping';
                } else {
                    alphaX_serverStatusEl.textContent = message || alphaX_translations[lang]?.disconnected || alphaX_translations['en']?.disconnected;
                    alphaX_serverStatusIndicator.className = 'w-3 h-3 bg-loss-color rounded-full';
                }
            }
        }
        function alphaX_showBadTrendIndicatorUI(message, details) { if(!alphaX_badTrendMessageTextEl || !alphaX_badTrendIndicatorEl) return; alphaX_badTrendMessageTextEl.textContent = message + (details ? ` (${details})` : ''); alphaX_badTrendIndicatorEl.style.display = 'flex'; if (alphaX_isNotificationsEnabled && Notification.permission === 'granted') { new Notification(alphaX_translations[alphaX_currentLanguage]?.trend_alert || "Trend Alert", { body: `${message}\n${details}`, icon: 'https://placehold.co/64x64/F59E0B/1A202C?text=AXA' }); } /* No sound here, handled by disablePredictionSystem */ }
        function alphaX_hideBadTrendIndicatorUI() { if(alphaX_badTrendIndicatorEl) alphaX_badTrendIndicatorEl.style.display = 'none'; }
        
        function alphaX_checkWinStreakAndNotify() {
            // Calculate current win streak based on *actual* history items that are 'Win'
            let currentActualWinStreak = 0;
            for (const entry of alphaX_appHistory) {
                if (entry.status === "Win") {
                    currentActualWinStreak++;
                } else if (entry.status === "Loss" || entry.status === "Skipped") { // Any non-win or non-pending breaks the streak
                    break; 
                }
                // Pending items don't break or contribute until resolved.
            }

            if (currentActualWinStreak >= 7 ) { // Trigger at 7 wins
                 const streakMsgKey = alphaX_translations[alphaX_currentLanguage].win_streak_popup_message || "Amazing! You're on a {STREAK_COUNT}-win streak. Predictions will pause for 20 minutes to maintain stability.";
                 const popupMessage = streakMsgKey.replace("{STREAK_COUNT}", currentActualWinStreak);
                
                if (alphaX_isNotificationsEnabled && Notification.permission === 'granted') { 
                    new Notification(alphaX_translations[alphaX_currentLanguage]?.streak_alert_title || 'Win Streak Alert', { 
                        body: popupMessage, 
                        icon: 'https://placehold.co/64x64/38A169/FFFFFF?text=AXA' 
                    }); 
                }
                if(alphaX_streakBreakMessageEl) alphaX_streakBreakMessageEl.textContent = popupMessage;
                if(alphaX_streakBreakPopupEl && !alphaX_streakBreakPopupEl.classList.contains('active') && !alphaX_isPredictionSystemDisabled) { // Show only if not already disabled
                    alphaX_streakBreakPopupEl.classList.add('active');
                    alphaX_playSound('alert');
                }
            }
        }

        function alphaX_closeStreakBreakPopupAndPause(durationMinutes) {
            if(alphaX_streakBreakPopupEl) alphaX_streakBreakPopupEl.classList.remove('active');
            const reason = (alphaX_translations[alphaX_currentLanguage].win_streak_popup_message || "Win streak pause.").replace("{STREAK_COUNT}", alphaX_currentStreak); // Use global streak for reason
            alphaX_disablePredictionSystem(reason, durationMinutes);
            alphaX_playSound('confirm');
        }


        function alphaX_openVideoPopup() { if(alphaX_youtubeVideoEl) alphaX_youtubeVideoEl.src = "https://www.youtube.com/embed/dQw4w9WgXcQ"; /* Example Video */ if(alphaX_videoPopupEl) alphaX_videoPopupEl.classList.add('active'); alphaX_playSound('open'); }
        function alphaX_closeVideoPopup() { if(alphaX_youtubeVideoEl) alphaX_youtubeVideoEl.src = ""; if(alphaX_videoPopupEl) alphaX_videoPopupEl.classList.remove('active'); alphaX_playSound('close'); }
        
        let alphaX_currentConfirmCallback = null;
        function alphaX_showConfirmModal(messageKey, onConfirm) { 
            const messageTemplate = alphaX_translations[alphaX_currentLanguage]?.[messageKey] || alphaX_translations['en']?.[messageKey] || "Are you sure?";
            let message = messageTemplate;
            // Specific message for delete all history confirmation
            if (messageKey === 'delete_all_confirm') {
                 message = alphaX_translations[alphaX_currentLanguage]?.delete_all_confirm || "Are you sure you want to delete all history items? This will pause predictions for 20 minutes.";
            }

            if(alphaX_modalMessageEl) alphaX_modalMessageEl.textContent = message; 
            if(alphaX_confirmModalEl) alphaX_confirmModalEl.classList.add('active'); 
            alphaX_currentConfirmCallback = onConfirm; 
            alphaX_playSound('open'); 
        }
        
        function alphaX_resetSettings() { alphaX_showConfirmModal('reset_settings_confirm', () => { alphaX_currentLanguage = 'en'; alphaX_isSoundEnabled = true; alphaX_isNotificationsEnabled = false; alphaX_isAdvancedModeActive = true; localStorage.setItem('alphaXAiLanguage', alphaX_currentLanguage); localStorage.setItem('alphaXAiSound', alphaX_isSoundEnabled.toString()); localStorage.setItem('alphaXAiNotifications', alphaX_isNotificationsEnabled.toString()); localStorage.setItem('alphaXAiPredictionMode', alphaX_isAdvancedModeActive ? 'advanced' : 'normal'); const langToggle = document.getElementById('languageToggle'); if(langToggle) langToggle.checked = false; const notifToggle = document.getElementById('notificationToggle'); if(notifToggle) notifToggle.checked = false; const soundToggle = document.getElementById('soundToggle'); if(soundToggle) soundToggle.checked = true; const predModeToggle = document.getElementById('predictionModeToggle'); if(predModeToggle) predModeToggle.checked = true; alphaX_updateLanguage(); alphaX_showLoginToast('Settings reset to default.', 'info'); alphaX_playSound('confirm'); }); }


        document.addEventListener('DOMContentLoaded', function() {
            // Login elements
            const telegramUsernameInputAlphaX_el = document.getElementById('telegramUsernameInputAlphaX');
            const submitUsernameBtnAlphaX_el = document.getElementById('submitUsernameBtnAlphaX');
            const copyDeviceIdBtnAlphaX_el = document.getElementById('copyDeviceIdBtnAlphaX');
            const logoutFromDevicePageBtnAlphaX_el = document.getElementById('logoutFromDevicePageBtnAlphaX');

            if(submitUsernameBtnAlphaX_el) submitUsernameBtnAlphaX_el.addEventListener('click', handleSubmitUsernameAlphaX);
            if(copyDeviceIdBtnAlphaX_el) copyDeviceIdBtnAlphaX_el.addEventListener('click', copyCurrentDeviceIdAlphaX);
            if(logoutFromDevicePageBtnAlphaX_el) logoutFromDevicePageBtnAlphaX_el.addEventListener('click', () => handleLogoutAlphaX(true));

            // Settings Toggles
            const langToggle = document.getElementById('languageToggle');
            if(langToggle) langToggle.addEventListener('change', (e) => { alphaX_currentLanguage = e.target.checked ? 'hi' : 'en'; localStorage.setItem('alphaXAiLanguage', alphaX_currentLanguage); alphaX_updateLanguage(); alphaX_playSound('toggle'); });
            const notifToggle = document.getElementById('notificationToggle');
            if(notifToggle) notifToggle.addEventListener('change', (e) => { alphaX_isNotificationsEnabled = e.target.checked; localStorage.setItem('alphaXAiNotifications', alphaX_isNotificationsEnabled.toString()); if(alphaX_isNotificationsEnabled && Notification.permission !== "granted") { Notification.requestPermission().then(p => { if(p !== 'granted') { alphaX_isNotificationsEnabled = false; localStorage.setItem('alphaXAiNotifications', 'false'); e.target.checked = false; alphaX_showLoginToast('Notifications denied.', 'info');} else {alphaX_showLoginToast('Notifications enabled!', 'success');} }); } else if (!alphaX_isNotificationsEnabled && alphaX_isNotificationsEnabled !==null) { alphaX_showLoginToast('Notifications disabled.', 'info');} alphaX_playSound('toggle'); });
            const soundToggle = document.getElementById('soundToggle');
            if(soundToggle) soundToggle.addEventListener('change', (e) => { alphaX_isSoundEnabled = e.target.checked; localStorage.setItem('alphaXAiSound', alphaX_isSoundEnabled.toString()); if (alphaX_isSoundEnabled) alphaX_playSound('toggle'); });
            const predModeToggle = document.getElementById('predictionModeToggle');
            if(predModeToggle) predModeToggle.addEventListener('change', (e) => { alphaX_isAdvancedModeActive = e.target.checked; localStorage.setItem('alphaXAiPredictionMode', alphaX_isAdvancedModeActive ? 'advanced' : 'normal'); alphaX_playSound('toggle'); alphaX_showLoginToast(`Prediction mode set to ${alphaX_isAdvancedModeActive ? 'Advanced' : 'Normal'}.`, 'info'); });
            
            // History Deletion
            const deleteAllHistoryBtn = document.getElementById('deleteAllHistoryBtn');
            if(deleteAllHistoryBtn) deleteAllHistoryBtn.addEventListener('click', () => { 
                alphaX_showConfirmModal('delete_all_confirm', () => { 
                    alphaX_appHistory = []; 
                    localStorage.removeItem('alphaXAiHistory_v2'); 
                    alphaX_lastFetchedPeriod = null; 
                    alphaX_currentStreak = 0; 
                    localStorage.setItem('alphaXCurrentStreak', '0'); 
                    alphaX_signalPerformance = {}; 
                    localStorage.removeItem('alphaXAiSignalPerformance_v2');
                    localStorage.setItem(LAST_HISTORY_CLEAR_TIMESTAMP_KEY, Date.now().toString()); // Mark history clear time
                    
                    alphaX_updateHistoryUI(); 
                    alphaX_updateDashboardAndStats(); 
                    alphaX_showLoginToast('All history deleted.', 'info'); 
                    alphaX_playSound('confirm'); 
                    
                    // Trigger anti-manipulation pause
                    alphaX_disablePredictionSystem(
                        alphaX_translations[alphaX_currentLanguage].system_integrity_pause || "System integrity check after history deletion.",
                        ANTI_MANIPULATION_DISABLE_MINUTES,
                        true 
                    );
                }); 
            });
            
            // Modal Buttons
            const confirmModalBtn = document.getElementById('confirmModalBtn');
            if(confirmModalBtn) confirmModalBtn.addEventListener('click', () => { if (alphaX_currentConfirmCallback) alphaX_currentConfirmCallback(); if(alphaX_confirmModalEl) alphaX_confirmModalEl.classList.remove('active'); alphaX_playSound('confirm'); alphaX_currentConfirmCallback = null; });
            const cancelModalBtn = document.getElementById('cancelModalBtn');
            if(cancelModalBtn) cancelModalBtn.addEventListener('click', () => { if(alphaX_confirmModalEl) alphaX_confirmModalEl.classList.remove('active'); alphaX_playSound('close'); alphaX_currentConfirmCallback = null; });
            
            // Video Popup Close
            const videoPopupEl_listener = document.getElementById('videoPopup');
            const videoPopupCloseButtons = videoPopupEl_listener ? videoPopupEl_listener.querySelectorAll('button') : []; // Assuming buttons are direct children or identifiable
            videoPopupCloseButtons.forEach(btn => { if(btn.textContent.toLowerCase().includes('close') || btn.textContent.toLowerCase().includes(alphaX_translations[alphaX_currentLanguage]?.cancel?.toLowerCase() || 'cancel')) btn.addEventListener('click', alphaX_closeVideoPopup); });

            // Streak Break Popup Buttons
            const streakBreakPopupEl_listener = document.getElementById('streakBreakPopup');
            const streakBreakContinueButton = streakBreakPopupEl_listener ? streakBreakPopupEl_listener.querySelector('#cancelStreakModalBtn') : null; // Keep Going button
             const streakBreakPauseButton = streakBreakPopupEl_listener ? streakBreakPopupEl_listener.querySelector('button.primary-btn') : null; // Pause button

            if(streakBreakContinueButton) streakBreakContinueButton.addEventListener('click', () => { if(alphaX_streakBreakPopupEl) alphaX_streakBreakPopupEl.classList.remove('active'); alphaX_playSound('close');});
            if(streakBreakPauseButton) streakBreakPauseButton.addEventListener('click', () => alphaX_closeStreakBreakPopupAndPause(WIN_STREAK_DISABLE_MINUTES));


            // Initial Load Logic
            currentDeviceIdAlphaX = getOrGenerateUserDeviceIdAlphaX();
            const isLoggedInAlphaX = localStorage.getItem(PREDICTOR_LOGGED_IN_KEY_ALPHAX) === 'true';
            const storedUsernameAlphaX = localStorage.getItem(TELEGRAM_USERNAME_STORAGE_KEY_ALPHAX);

            db.ref("alphax_maintenanceStatus/status").get().then(statusSnapshot => {
                const isMaintenanceActive = statusSnapshot.val() === true;
                alphaX_isMaintenanceModeActive = isMaintenanceActive; 
                if (isMaintenanceActive) {
                    db.ref("alphax_maintenanceStatus/message").get().then(messageSnapshot => {
                        const message = messageSnapshot.val() || "ALPHA X AI is currently under maintenance.";
                        showMaintenancePageAlphaX(message);
                    }).catch(err => { console.error("Error fetching AlphaX maintenance message:", err); showMaintenancePageAlphaX("ALPHA X AI is currently under maintenance."); });
                } else { // Not in maintenance
                    if (isLoggedInAlphaX && storedUsernameAlphaX && currentDeviceIdAlphaX) {
                        if(telegramUsernameInputAlphaX_el) telegramUsernameInputAlphaX_el.value = storedUsernameAlphaX;
                        showScreenAlphaX('loginPage2AlphaX'); updateApprovalStatusUIAlphaX('info', 'Verifying access...'); startApprovalCheckAlphaX();
                    } else if (storedUsernameAlphaX && currentDeviceIdAlphaX) { // Has username and device ID but not explicitly logged in
                        if(telegramUsernameInputAlphaX_el) telegramUsernameInputAlphaX_el.value = storedUsernameAlphaX;
                        showScreenAlphaX('loginPage2AlphaX'); startApprovalCheckAlphaX(); // Go to approval check
                    } else { // No stored info, fresh start
                        showScreenAlphaX('loginPage1AlphaX');
                    }
                }
            }).catch(error => { // Error fetching maintenance status
                console.error("Error checking AlphaX maintenance status on load:", error);
                alphaX_isMaintenanceModeActive = false; // Assume not in maintenance if check fails
                 if (isLoggedInAlphaX && storedUsernameAlphaX && currentDeviceIdAlphaX) { if(telegramUsernameInputAlphaX_el) telegramUsernameInputAlphaX_el.value = storedUsernameAlphaX; showScreenAlphaX('loginPage2AlphaX'); updateApprovalStatusUIAlphaX('info', 'Verifying access...'); startApprovalCheckAlphaX(); }
                 else if (storedUsernameAlphaX && currentDeviceIdAlphaX) { if(telegramUsernameInputAlphaX_el) telegramUsernameInputAlphaX_el.value = storedUsernameAlphaX; showScreenAlphaX('loginPage2AlphaX'); startApprovalCheckAlphaX(); }
                 else { showScreenAlphaX('loginPage1AlphaX'); }
            });
        });
    </script>
</body>
</html>
